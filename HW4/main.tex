\documentclass{report}

\usepackage{enumitem}
\usepackage[outputdir=./]{minted}
\usepackage{amsmath}
\usepackage{hyperref}

\input{Boostan-UserManual}

\title{پیک ساماریوم}
\type{}
\author{
محمد مهدی اقدسی 400521081 \\
علی شکوهی 400521477 \\
دانیال یگانه 400522337
}

\begin{document}
\pagenumbering{gobble}
\Godpage
\logofile{Pictures/IUST_logo_color.jpg}

\maketitle
\pagenumbering{arabic}
\tableofcontents

\chapter{سوالات تئوری}
\section{سوال اول}

\subsection*{DTLS چیست؟}
پروتکل \textbf{امنیت لایه انتقال دیتاگرام (DTLS)} یک پروتکل ارتباطی است که برای تأمین امنیت برنامه‌های مبتنی بر دیتاگرام طراحی شده است. این پروتکل یک گسترش از پروتکل \textbf{امنیت لایه انتقال (TLS)} است، اما بر روی \textbf{پروتکل دیتاگرام کاربر (UDP)} به جای TCP ساخته شده است. این پروتکل مناسب برنامه‌هایی است که به انتقال سریع داده نیاز دارند و حساس به تأخیرها می‌باشند، مانند بازی‌های آنلاین، استریم ویدئو و \lr{VoIP}.
	
\subsection*{ویژگی‌های کلیدی \lr{DTLS}:}
\begin{itemize}
	\item \textbf{امنیت}:
	 \lr{DTLS}
	 با رمزگذاری بسته‌های داده، حفظ حریم خصوصی و یکپارچگی داده را تأمین می‌کند و مانع از جاسوسی، دستکاری و جعل پیام‌ها می‌شود.
	\item \textbf{مبتنی بر دیتاگرام}:
	 برخلاف \lr{TCP}، \lr{UDP} تضمین نمی‌کند که بسته‌ها به ترتیب یا حتی به مقصد برسند. \lr{DTLS} با مدیریت ترتیب‌دهی مجدد بسته‌ها و از دست رفتن بسته‌ها، تجربه‌ای مطمئن و امن از ارتباط را فراهم می‌کند.
	\item \textbf{کارایی}:
	 \lr{DTLS}
	از تأخیرهای مربوط به پروتکل‌های جریان داده جلوگیری می‌کند و آن را برای برنامه‌های زمان واقعی ایده‌آل می‌سازد.
\end{itemize}

\subsection*{جریان پیام در \lr{DTLS}:}

\subsection*{مرحله هم‌آهنگی}	فرآیند هم‌آهنگی در DTLS به دلیل غیرقابل اعتماد بودن و نبود ترتیب در UDP کمی پیچیده‌تر از TLS است. مراحل اصلی شامل موارد زیر است:
	
\subsubsection*{ClientHello}
\begin{itemize}
	\item
	 کاربر یک پیام \textbf{ClientHello} ارسال می‌کند که شامل نسخه پروتکل، مقادیر تصادفی، شناسه نشست، مجموعه‌های رمزنگاری و روش‌های فشرده‌سازی است.
\end{itemize}

\subsubsection*{ServerHello}
\begin{itemize}
	\item
	 سرور با یک پیام \textbf{ServerHello} پاسخ می‌دهد که شامل فیلدهای مشابه \textbf{ClientHello} است. این پیام همچنین گواهی سرور (\lr{Certificate message}) را شامل می‌شود و ممکن است گواهی کاربر نیز درخواست شود.
\end{itemize}

\subsubsection*{ServerKeyExchange}
\begin{itemize}
	\item
	 اگر لازم باشد، سرور یک پیام \textbf{ServerKeyExchange} ارسال می‌کند. این پیام در صورتی استفاده می‌شود که گواهی سرور شامل اطلاعات کافی برای تکمیل تبادل کلید نباشد.
\end{itemize}

\subsubsection*{\lr{CertificateRequest} (اختیاری)}
\begin{itemize}
	\item
	 سرور ممکن است از کاربر بخواهد که یک گواهی ارائه دهد اگر نیاز به احراز هویت دو طرفه باشد.
\end{itemize}

\subsubsection*{ServerHelloDone}
\begin{itemize}
	\item
	 سرور یک پیام \textbf{ServerHelloDone} ارسال می‌کند تا نشان دهد که مرحله پیام‌های هماهنگی کامل شده است.
\end{itemize}

\subsubsection*{گواهی کاربر (اختیاری)}
\begin{itemize}
	\item
	 اگر سرور گواهی درخواست کرده باشد، کاربر پیام \textbf{Certificate} خود را ارسال می‌کند.
\end{itemize}

\subsubsection*{ClientKeyExchange}
\begin{itemize}
	\item 
	کاربر یک پیام \textbf{ClientKeyExchange} ارسال می‌کند که حاوی کلید عمومی کاربر یا پیش رمز عبور لازم برای برقراری یک کلید مشترک است.
\end{itemize}

\subsubsection*{CertificateVerify (اختیاری)}
\begin{itemize}
	\item اگر نیاز به احراز هویت کاربر باشد، کاربر یک پیام \textbf{CertificateVerify} ارسال می‌کند تا گواهی خود را تایید کند.
\end{itemize}

\subsubsection*{پایان یافته}
\begin{itemize}
	\item
	 پس از اینکه همه پیام‌های قبلی رد و بدل شدنده ر دو کاربر و سرور یک پیام \textbf{Finished} برای یکدیگر ارسال می‌کنند. پیام \textbf{Finished} رمزگذاری شده و اطمینان حاصل می‌کند که هم‌آهنگی موفقیت آمیز بوده و تمام پیام‌ها دستکاری نشده‌اند.
\end{itemize}

\subsection*{مرحله انتقال داده}
پس از تکمیل هم‌آهنگی، داده‌ها می‌توانند به صورت امن بین کاربر و سرور منتقل شوند. داده‌ها رمزگذاری می‌شوند و DTLS صحت و اصالت بسته‌ها را تضمین می‌کند.
	
\subsubsection*{داده‌های کاربردی}
\begin{itemize}
	\item
	 این مرحله شامل تبادل داده‌های رمزگذاری شده کاربردی بین کاربر و سرور است. DTLS مدیریت ترتیب‌دهی مجدد بسته‌ها، از دست رفتن و تکثیر بسته‌ها را برای اطمینان از انتقال مطمئن داده‌ها بر روی UDP به عهده دارد.
\end{itemize}

\subsection*{مرحله کلید مجدد (اختیاری)}
برای جلسات طولانی مدت، ممکن است نیاز به کلید مجدد برای حفظ امنیت باشد. این شامل تکرار بخشی از هم‌آهنگی برای برقراری کلیدهای رمزنگاری جدید بدون قطع کردن جلسه جاری است.
	
\subsubsection*{درخواست کلید مجدد}
\begin{itemize}
	\item
	 هر یک از طرفین می‌توانند با ارسال یک پیام \textbf{ClientHello} جدید، درخواست کلید مجدد کنند و فرآیند هم‌آهنگی مجدداً برای برقراری کلیدهای جدید آغاز می‌شود.
\end{itemize}

\subsection*{مرحله خاتمه}	در نهایت، جلسه می‌تواند توسط کاربر یا سرور خاتمه یابد.
	
\subsubsection*{CloseNotify}
\begin{itemize}
	\item
	 طرفی که می‌خواهد جلسه را خاتمه دهد، یک هشدار \textbf{CloseNotify} ارسال می‌کند. طرف دیگر با ارسال پیام \textbf{CloseNotify} خود پاسخ می‌دهد و ارتباط بسته می‌شود.
\end{itemize}

\section{سوال دوم}

\textbf{حمله \lr{Downgrade}}
در \lr{TLS} زمانی رخ می‌دهد که مهاجم سعی می‌کند ارتباط را به نسخه‌ای قدیمی‌تر یا الگوریتم‌های ضعیف‌تر \lr{TLS} کاهش دهد تا بتواند امنیت ارتباط را نقض کند. این حمله به مهاجم اجازه می‌دهد تا از ضعف‌های نسخه‌های قدیمی‌تر \lr{TLS} بهره‌برداری کند.

انواع حمله \lr{Downgrade}:
\begin{enumerate}
	\item \textbf{\lr{Protocol Downgrade}}:
	 کاهش نسخه پروتکل \lr{TLS} به نسخه‌ای قدیمی‌تر مانند \lr{TLS 1.0} یا \lr{SSL}
	\item \textbf{\lr{Cipher Suite Downgrade}}:
	 تغییر الگوریتم‌های رمزنگاری قوی به الگوریتم‌های ضعیف‌تر مانند \lr{RC4} یا \lr{DES}
	\item \textbf{\lr{Feature Downgrade}}:
	 کاهش ویژگی‌های امنیتی مانند حذف \lr{Perfect Forward Secrecy (PFS)}
\end{enumerate}

روش‌های مقابله با حمله \lr{Downgrade}:
\begin{enumerate}
	\item 
	پیکربندی سرور و کلاینت به گونه‌ای که تنها نسخه‌ها و الگوریتم‌های قوی را پشتیبانی کنند.
	\item 
	استفاده از مکانیزم‌های امنیتی مانند \lr{TLS\_FALLBACK\_SCSV} که از کاهش ناخواسته نسخه جلوگیری می‌کند.
	\item 
	استفاده از \lr{HSTS (HTTP Strict Transport Security)} برای اطمینان از استفاده از \lr{TLS} در ارتباطات.
	\item
	به‌روز نگه داشتن نرم‌افزارها و سرورها برای حمایت از آخرین نسخه‌های \lr{TLS}.
\end{enumerate}

\section{سوال سوم}

\textbf{گواهی ریشه (\lr{Root Certificate})}
یک گواهی دیجیتال است که توسط یک مرجع صدور گواهی (\lr{Certificate Authority-CA}) معتبر صادر شده و به عنوان پایه‌ای برای اعتبارسنجی دیگر گواهی‌ها عمل می‌کند. این گواهی‌ها به‌صورت پیش‌فرض در سیستم‌عامل‌ها و مرورگرهای وب ذخیره شده‌اند و به کاربران امکان می‌دهند تا هویت سرورها و سرویس‌های آنلاین را تایید کنند.

\textbf{تأیید گواهی ریشه از سمت کاربر:}
\begin{enumerate}
	\item \textbf{ذخیره‌سازی در مخزن گواهی‌های معتبر}:
	 سیستم‌عامل و مرورگرها دارای یک مخزن از گواهی‌های ریشه معتبر هستند.
	\item \textbf{اعتبارسنجی زنجیره گواهی‌ها}:
	 هنگام اتصال به یک سرور، گواهی سرور توسط زنجیره‌ای از گواهی‌ها تا گواهی ریشه دنبال می‌شود تا اطمینان حاصل شود که هر گواهی توسط گواهی بالاتر آن اعتبارسنجی شده است.
	\item \textbf{بررسی اعتبار و انقضای گواهی}:
	 سیستم بررسی می‌کند که گواهی ریشه معتبر و منقضی نشده باشد.
	\item
	استفاده از پروتکل‌های امنیتی مانند \lr{OCSP (Online Certificate Status Protocol)} برای بررسی وضعیت گواهی‌ها به صورت آنلاین.
\end{enumerate}

\section{سوال چهارم}

\textbf{\lr{Samy Kamkar}}
یا سامی کامکار یک هکر و توسعه‌دهنده نرم‌افزار آمریکایی است که به خاطر فعالیت‌های امنیتی و برخی حملات معروف خود شناخته می‌شود. او به عنوان یک محقق امنیتی در زمینه امنیت وب و دستگاه‌های موبایل فعالیت می‌کند و چندین ابزار امنیتی و حملات معروف را توسعه داده است.

\subsubsection*{فعالیت‌های معروف سامی کامکار}
\begin{enumerate}
	\item \textbf{حمله \lr{Cross-Site Scripting (XSS)} در \lr{MySpace}}:
	 در سال ۲۰۰۵، او حمله‌ای \lr{XSS} بر روی شبکه اجتماعی \lr{MySpace} انجام داد که منجر به ایجاد پروفایل خود با نام \lr{"Samy"} شد و به سرعت به ویروسی شدن پروفایل او منجر گردید.
	\item \textbf{\lr{Pineapple WiFi}}:
	 توسعه دستگاه‌هایی برای تست و تحلیل امنیت شبکه‌های \lr{WiFi}.
	\item \textbf{\lr{Phantom}}:
	یک ابزار برای سوءاستفاده از آسیب‌پذیری‌های \lr{DNS}.
	\item \textbf{برنامه‌های مختلف امنیتی}:
	 توسعه ابزارها و برنامه‌های مختلف برای تحلیل امنیت و تست نفوذ.
\end{enumerate}

\chapter{سوالات عملی}

\section{سوال اول}

برای استخراج جریان پیام \lr{TLS}، نیازمند برنامه‌ای هستیم که بتواند با یک سرور ارتباط برقرار پیدا کرده و رازهای رمزنگاری را در مکانی ذخیره کند، و به برنامه‌ای نیاز داریم که بتواند بسته‌های ردوبدل شده را ضبط کرده و در فایلی ذخیره بکند تا بعدا بتوانیم به آنها دسترسی داشته باشیم. برای ارتباط با سرور از \lr{OpenSSL} و برای ضبط بسته‌ها از \lr{tcpdump} استفاده می‌کنیم.

اول دستور زیر را اجرا می‌کنیم تا بسته‌های ردوبدل شده را ضبط کنیم:
\begin{LTR}
	\begin{latin}
		sudo tcpdump -i any host google.com -w output.pcap
	\end{latin}
\end{LTR}

\noindent
آپشن‌های مورد استفاده:
\begin{itemize}
	\item
	\lr{-i any}:
	ترافیک را بر روی تمامی اینترفیس‌ها ضبط می‌کند.
	\item 
	\lr{host google.com}:
	بسته‌هایی را دریافت می‌کند که مرتبط با سرور ما (در اینجا \lr{google.com}) می‌باشد.
	\item 
	\lr{-w output.pcap}:
	بسته‌های ضبط شده را در داخل فایل \lr{output.pcap} ذخیره می‌کند.
\end{itemize}

\noindent
سپس دستور زیر را اجرا می‌کنیم تا یک ارتباط با سرور مورد نظر (\lr{google.com}) برقرار کنیم:
\begin{LTR}
	\begin{latin}
		openssl s\_client -connect google.com:443 -keylogfile /home/daniyeg/sslkeys.log -tls1\_3
	\end{latin}
\end{LTR}

\noindent
آپشن‌های مورد استفاده:
\begin{itemize}
	\item
	\lr{s\_client}:
	برای برقراری ارتباط از آن استفاده می‌شود.
	\item 
	\lr{-connect google.com:443}:
	مقصد را مشخص می‌کند که در اینجا پورت ۴۴۳ (مربوط به \lr{HTTPS}) در سایت \lr{google.com} می‌باشد.
	\item 
	\lr{-keylogfile /home/daniyeg/sslkeys.log}:
	مشخص می‌کند که رازهای رمزنگاری این نشست در کدام فایل باید ذخیره شوند.
	\item 
	\lr{-tls1\_3}:
	مشخص می‌کند که تنها از \lr{TLS 1.3} برای برقراری ارتباط استفاده شود.
\end{itemize}

پس از برقراری ارتباط نیز درخواست \lr{HTTP} ساده زیر را برای سرور می‌فرستیم و ارتباط را قطع می‌کنیم:
\begin{LTR}
	\begin{latin}
		GET https://google.com HTTP/1.1

		Host: google.com
	\end{latin}
\end{LTR}

حالا دارای دو فایل می‌باشیم: \lr{output.pcap} که شامل بسته‌های ما می‌باشد و \lr{sslkeys.log} که شامل رازهای رمزنگاری نشست می‌باشد. سپس می‌توانیم این فایل‌ها را در \lr{Wireshark} باز کنیم تا محتوای آن را به صورت رمزگشایی شده بدست آوریم.

\noindent
اول فایل \lr{output.pcap} را در \lr{Wireshark} باز می‌کنیم. همانطور که مشاهده می‌شود پیام‌های ما رمز شده می‌باشند:
\begin{figure}[H]
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/tls1.jpg}
	\label{tls1}
\end{figure}

\noindent
سپس در برنامه \lr{Wireshark} از منوی بالا به بخش \lr{Edit -> Preferences} رفته و در منوی بغل \lr{Protocols -> TLS} را انتخاب کرده و فایل مورد نظر خود را در بخش \lr{(Pre)-Master-Secret log filename} انتخاب می‌کنیم.
\begin{figure}[H]
	\centering
	\includegraphics[width=.7\textwidth]{Pictures/tls2.jpg}
	\label{tls2}
\end{figure}

\noindent
حالا می‌توانیم محتویات پیام‌ها را به صورت رمزگشایی شده ببینیم. می‌توان مشاهده کرد که ۴ پیام برای برقراری ارتباط \lr{TLS} رد و بدل شده است که در ادامه به محتویات آنها خواهیم پرداخت:
\begin{figure}[H]
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/tls3.jpg}
	\label{tls3}
\end{figure}

تصویر زیر محتویات پیام اول را نشان می‌دهد که شامل رکورد \lr{Client Hello} می‌باشد. این رکورد شامل فیلدهای زیر می‌باشد:
\begin{itemize}
	
	\item \lr{Version}:
	فیلد نسخه که نسخه ارتباطات را مشخص می‌کند. این فیلد در \lr{TLS 1.3} استفاده نمی‌شود و همواره دارای مقادیر \lr{0x301} به معنای \lr{TLS 1.0} یا \lr{0x303} به معنای \lr{TLS 1.2} می‌باشد.
	\item \lr{Random}:
	یک عدد رندوم ۳۲ بایتی که توسط کلاینت تولید شده است و در تولید کلیدهای نهایی برای رمزنگاری نقش دارد.
	
	\item \lr{Session ID}:
	یک شناسه یکتا که مختص این اتصال می‌باشد و برای سرگیری اتصال در اتصال‌های بعد استفاده می‌شود تا سرعت اتصال مجدد بهبود یافته و میزان اطلاعات تکراری کمتر شود.
	\item \lr{Cipher Suites}:
	الگوریتم‌های رمزنگاری را مشخص می‌کند که کلاینت از آنها پشتیبانی می‌کند و مایل است که در این اتصال از آن استفاده کند.
	\item \lr{Compression Methods}:
	الگوریتم‌های فشرده‌سازی را مشخص می‌کند که کلاینت مایل است از آنها استفاده شود (در این مثال این فیلد خالی می‌باشد که به معنای فشرده نبودن پیام‌ها می‌باشد).
	
\end{itemize}

سپس چندین \lr{extension} رد و بدل می‌شود که محتویات این اکستنشن‌ها برای عملکرد این پروتکل مهم است. اکستنشن‌های مهم در این پیام عبارتند از:
\begin{itemize}
	
	\item \lr{server\_name}:
	دامنه سروری که کلاینت می‌خواهد به آن متصل شود.
	
	\item \lr{supported\_groups}:
	منحنی بیضی و گروه‌های میدان محدودی را که کلاینت برای تبادل کلید از آنها پشتیبانی می کند نشان می‌دهد و مربوط به رمزنگاری بیضوی دیفی-هلمن می‌باشد.
	
	\item \lr{session\_ticket}:
	این فیلد مشخص می‌کند که آیا کلاینت دارای \lr{Session Ticket} ای می‌باشد یا خیر. از \lr{Session Ticket} برای کاهش طول فرآیند دست دادن در اتصال مجدد به یک سرور استفاده می‌شود.

	\item \lr{encrypt\_then\_mac}:
	این اکستنشن مشخص می‌کند که پیام‌ها اول باید رمز شوند و سپس توسط مکانیسم \lr{MAC} یکپارچگی پیام‌ها تضمین شود.

	\item \lr{signature\_algorithms}:
الگوریتم‌های امضای دیجیتالی که کلاینت از انها پشتیبانی می‌کند.
	
	\item \lr{supported\_versions}:
	نسخه‌های TLS پشتیبانی شده توسط کلاینت. در این اکستنشن نسخه‌های واقعی پروتکل تعیین می‌شود.
	
	\item \lr{key\_share}:
اطلاعات مربوط به توافق کلید کلاینت در روش‌های مبتنی بر دیفی-هلمن.

\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/tls4.jpg}
	\label{tls4}
\end{figure}

تصویر زیر محتویات پیام دوم را نشان می‌دهد که شامل دو رکورد می‌باشد. اولین رکورد یعنی \lr{Server Hello} شامل فیلدهای زیر و اکستنشن‌های می‌باشد:
\begin{itemize}
	\item \lr{Random}:
	یک عدد رندوم ۳۲ بایتی که توسط سرور تولید شده است و در تولید کلیدهای نهایی برای رمزنگاری نقش دارد.
	
	\item \lr{Session ID}:
	شناسه یکتایی که توسط کلاینت تولید شده و توسط سرور تائید شده است.
	
	\item \lr{Cipher Suite}:
	الگوریتم رمزنگاری که قرار است از آن در این اتصال از آن استفاده شود.
	
	\item \lr{Compression Method}:
	الگوریتم فشرده‌سازی که قرار است از آن استفاده شود (در این مثال از فشرده‌سازی استفاده نشده است).
	
	\item \lr{supported\_versions}:
	نسخه پروتکل TLS که از آن استفاده می‌شود. نسخه واقعی پروتکل در این فیلد مشخص شده است که \lr{TLS 1.3} می‌باشد.
	
	\item \lr{key\_share}:
	اطلاعات مربوط به توافق کلید سرور در روش‌های مبتنی بر دیفی-هلمن.
	
\end{itemize}

رکورد بعدی \lr{Change Cipher Spec} می‌باشد که شامل فیلدی نبوده و صرفا به کلاینت اطلاع می‌دهد که از اینجا به بعد اطلاعات رد و بدل شده به صورت رمزی فرستاده می‌شوند.
\begin{figure}[H]
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/tls5.jpg}
	\label{tls5}
\end{figure}

در پیام بعدی که نیز از سمت سرور می‌باشد چندین رکورد به صورت رمزنگاری شده وجود دارد. رکورد اول \lr{Encrypted Extensions} می‌باشد که اکستنشن‌هایی را به صورت رمزی برای کلاینت می‌فرستد(در اینجا اکستنشنی وجود ندارد). رکورد بعدی صرفا شامل گواهی سرور برای تائید صحت کلید عمومی به اشتراک گذاشته شده در \lr{key\_share} پیام قبل می‌باشد. در رکورد بعدی به نام \lr{Certificate Verify} سرور در اختیار داشتن کلید خصوصی متناظر با کلید عمومی درج شده در گواهی را به کلاینت اثبات می‌کند. این رکورد شامل یک امضا (که الگوریتم هش آن در این رکورد نیز ذکر شده است) از تمام محتویات دست دادن TLS تا پایان ارسال گواهی می‌باشد که در صورتی که کلاینت بتواند این امضا را تایید کند در دست داشتن کلید خصوصی گواهی برای کلاینت اثبات می‌شود.

در آخر نیز رکورد Finished می‌باشد. این رکورد دارای یک هش (\lr{Verify Data}) از تمامی پیام‌های ردوبدل شده در طول دست دادن می‌باشد تا کلاینت بتواند صحت اطلاعات پیام‌های دریافتی را با استفاده از مقایسه این هش با هش محاسبه شده توسط خود تایید کند.
\begin{figure}[H]
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/tls6.jpg}
	\label{tls6}
\end{figure}

تصویر زیر محتویات پیام چهارم و آخر را نشان می‌دهد که در آن دو رکورد TLS از سمت کلاینت به سمت سرور ارسال شده است. رکورد اول \lr{Change Cipher Spec} می‌باشد که به سرور اطلاع می‌دهد از این به بعد کلاینت پیام‌های خود را به صورت رمز شده ارسال می‌کند. رکورد دوم نیز رکورد \lr{Finished} می‌باشد که هدف آن در بخش قبلی توضیح داده شد.
\begin{figure}[H]
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/tls7.jpg}
	\label{tls7}
\end{figure}

در نهایت می‌توان پیام‌های \lr{HTTP/1.1} ردوبدل شده را مشاهده کرد.

\subsection*{مزایای \lr{TLS 1.3} نسبت به \lr{TLS 1.2}}

\subsubsection*{افزایش امنیت}
\begin{itemize}[noitemsep]
	\item \textbf{دست دادن ساده‌تر}:
	\lr{TLS 1.3}
	 لگوریتم‌ها و رمزهای رمزنگاری کمتر امن را حذف کرده و فرآیند دست دادن را ساده‌تر می‌کند که باعث می‌شود در برابر حملات مقاوم‌تر باشد.
	\item \textbf{رمزنگاری با راز رو به جلو}:
	در این نسخه تنها اجازه استفاده از رمزهایی که رمزنگاری با راز رو به جلو را فراهم می‌کنند داده می‌شود تا اطمینان حاصل شود که کلیدهای نشست حتی در صورت به خطر افتادن کلیدهای بلندمدت امن باقی می‌مانند.
	\item \textbf{\lr{encrypt-then-MAC}}:
	 به‌صورت پیش‌فرض از روش رمزنگاری-سپس-رمز صحت پیروی می‌کند و داده‌ها را یکپارچه و امن می‌سازد.
\end{itemize}

\subsubsection*{بهبود عملکرد}
\begin{itemize}[noitemsep]
	\item \textbf{کاهش تأخیر}:
	فرآیند دست دادن به تعداد کمتری رفت و برگشت بین کلاینت و سرور نیاز دارد که منجر به زمان اتصال سریع‌تر می‌شود. در بسیاری از موارد به سرعت یک رفت و برگشت واحد است.
	\item \textbf{از سرگیری با صفر رفت و برگشت \lr{0-RTT}}:
	این ویژگی اجازه استفاده مجدد از نشست قبلی برای اتصالات سریع‌تر بعدی را بدون به خطر انداختن امنیت می‌دهد.
\end{itemize}

\subsubsection*{بهبود حریم خصوصی}
\begin{itemize}[noitemsep]
	\item \textbf{راز کامل به جلو}:
	 هر نشست از یک کلید موقتی جدید استفاده می‌کند که باعث می‌شود داده‌های نشست‌های گذشته در صورت به خطر افتادن کلیدهای بلندمدت غیرقابل دسترس باشند.
	\item \textbf{نمایش کمتر متاداده}:
	 مقدار متاداده‌ی نمایش داده‌شده در فرآیند دست دادن را به حداقل می‌رساند که حریم خصوصی بهتری برای کاربران فراهم می‌کند.
\end{itemize}

\subsubsection*{ساده‌سازی پروتکل}
\begin{itemize}[noitemsep]
	\item \textbf{رمزهای ساده‌تر}:
	 تعداد رمزهای پشتیبانی‌شده را کاهش داده و گزینه‌های منسوخ و کمتر امن را حذف می‌کند.
	\item \textbf{مشخصات تمیزتر}:
	 پروتکل ساده‌تر و آسان‌تر برای پیاده‌سازی به صورت صحیح است که احتمال وجود اشکال و آسیب‌پذیری را کاهش می‌دهد.
\end{itemize}

\section{سوال دوم}

در این بخش، به پیاده‌سازی طرح تسهیم راز \lr{Shamir} برای تقسیم یک رمز عبور ۵۱۲ بیتی به ۱۰ سهم با آستانه ۵ پرداخته شده است. هدف این طرح این است که اگر حداقل ۵ نفر از سهم‌ها جمع شوند، بتوانند راز اصلی را بازسازی کنند و در صورت جمع شدن کمتر از ۵ سهم، اطلاعاتی از راز قابل استخراج نباشد.

\subsection*{بخش اول: شرح طرح تسهیم راز \lr{Shamir}}
\textbf{\lr{Shamir's Secret Sharing}}
یک روش رمزنگاری مبتنی بر نظریه اشکال است که به شما امکان می‌دهد یک راز را به چندین سهم تقسیم کنید به طوری که حداقل تعداد مشخصی از این سهم‌ها برای بازسازی راز اصلی نیاز باشد. این روش از خصوصیات چندجمله‌ای برای اطمینان از امنیت راز استفاده می‌کند.

\subsubsection*{مراحل طرح \lr{Shamir}:}
\begin{enumerate}
	\item \textbf{نمایش راز به عنوان یک عدد بزرگ:}
	 رمز عبور ۵۱۲ بیتی به عنوان یک عدد بزرگ در نظر گرفته می‌شود.
	\item \textbf{ایجاد یک چندجمله‌ای با درجه \lr{t-1} (در اینجا ۴):}
	 ضرایب چندجمله‌ای به طور تصادفی انتخاب می‌شوند.
	\item \textbf{محاسبه سهم‌ها:}
	 هر سهم به صورت نقطه‌ای (x, y) روی این چندجمله‌ای محاسبه می‌شود.
	\item \textbf{بازیابی راز:}
	 با داشتن حداقل t سهم، می‌توان از طریق روش‌های ریاضی مانند تداخل لگرانژ، چندجمله‌ای را بازسازی کرد و راز را بازیابی نمود.
\end{enumerate}

\subsection*{بخش دوم: پیاده‌سازی طرح تسهیم راز \lr{Shamir} با \lr{Python}}
در ادامه، پیاده‌سازی ساده‌ای از طرح تسهیم راز \lr{Shamir} با استفاده از \lr{Python} ارائه شده است.

\subsubsection*{شرح کد:}
\begin{itemize}
	\item \textbf{\lr{mod\_inv(a, p)}}:
	محاسبه معکوس ماژولی عدد `a` در میدان عددی `p` با استفاده از قضیه کوچک فرما.
	\item \textbf{\lr{generate\_polynomial(secret, threshold, prime)}}:
	ایجاد یک چندجمله‌ای با درجه `threshold - 1` که ضریب آزاد آن برابر راز است و بقیه ضرایب به صورت تصادفی انتخاب می‌شوند.
	\item \textbf{\lr{evaluate\_polynomial(coefficients, x, prime)}}:
	محاسبه مقدار `y` برای یک مقدار خاص `x` در چندجمله‌ای داده شده.
	\item \textbf{\lr{split\_secret(secret, n, threshold, prime)}}:
	تقسیم راز به `n` سهم با آستانه `threshold` با استفاده از چندجمله‌ای تولید شده.
	\item \textbf{\lr{reconstruct\_secret(shares, prime)}}:
	بازسازی راز اصلی از طریق سهم‌ها با استفاده از تداخل لگرانژ.
\end{itemize}

\subsubsection*{تست و تأیید عملکرد کد}
برای اطمینان از صحت عملکرد کد، مراحل زیر انجام شده است:
\begin{enumerate}
	\item \textbf{تولید راز تصادفی ۵۱۲ بیتی:} یک عدد تصادفی ۵۱۲ بیتی به عنوان راز تولید شده است.
	\item \textbf{تقسیم راز به ۱۰ سهم با آستانه ۵:} راز به ۱۰ سهم تقسیم شده است.
	\item \textbf{انتخاب تصادفی ۵ سهم برای بازسازی راز:} ۵ سهم به طور تصادفی انتخاب شده‌اند.
	\item \textbf{بازسازی راز و مقایسه با راز اصلی:} راز بازسازی شده با راز اصلی مقایسه شده و صحت آن تایید گردیده است.
\end{enumerate}

\subsection*{بخش سوم: گزارش و تحلیل}

\subsubsection*{توضیحات کلی}
 در این پروژه، از زبان برنامه‌نویسی Python برای پیاده‌سازی طرح تسهیم راز Shamir استفاده شده است. هدف اصلی این پیاده‌سازی، تقسیم یک رمز عبور ۵۱۲ بیتی به ۱۰ سهم با آستانه ۵ بوده است. این طرح اطمینان می‌دهد که اگر حداقل ۵ نفر از سهم‌ها جمع شوند، راز اصلی قابل بازسازی است و در صورت جمع شدن کمتر از ۵ سهم، راز اصلی تقریباً غیرقابل استخراج باقی می‌ماند.

\subsubsection*{مزایا و معایب طرح Shamir}
 \textbf{مزایا}:
\begin{itemize}
	\item \textbf{امنیت بالا}:
	      بازسازی راز نیازمند حداقل تعداد مشخصی از سهم‌ها است و اگر تعداد سهم‌های جمع‌شده کمتر از آستانه باشد، اطلاعاتی از راز قابل استخراج نیست.
	\item \textbf{قابلیت انعطاف‌پذیری}:
	      امکان تنظیم تعداد کل سهم‌ها و آستانه بازسازی راز به دلخواه.
	\item \textbf{سادگی پیاده‌سازی}:
	      پیاده‌سازی ساده و قابل درک با استفاده از مفاهیم ریاضی پایه.
\end{itemize}

\textbf{معایب}:
\begin{itemize}
	\item \textbf{نیاز به حافظه زیاد}:
	      برای رمزهای بسیار بزرگ، اندازه چندجمله‌ای و محاسبات ممکن است نیاز به حافظه زیادی داشته باشد.
	\item \textbf{پیچیدگی محاسباتی}:
	      بازسازی راز نیازمند محاسبات پیچیده‌ای مانند تداخل لگرانژ است که ممکن است برای مجموعه‌های بسیار بزرگ بهینه نباشد.
\end{itemize}

\subsubsection*{نتایج به دست آمده}
 با اجرای کد ارائه شده، یک رمز عبور تصادفی ۵۱۲ بیتی تولید شده و به ۱۰ سهم تقسیم گردید. سپس با انتخاب تصادفی ۵ سهم از میان این ۱۰ سهم، راز اصلی بازسازی شد و صحت بازسازی با راز اصلی تایید گردید.

\begin{itemize}
	\item \textbf{سهم‌ها}:
	 ۱۰ سهم تولید شدند که هر کدام شامل یک عدد `x` و مقدار `y` هستند.
	\item \textbf{سهم‌های انتخاب شده برای بازسازی}:
	 ۵ سهم به طور تصادفی انتخاب شدند.
	\item \textbf{بازسازی راز}:
	 راز بازسازی شده با راز اصلی برابر بود، که نشان‌دهنده صحت پیاده‌سازی طرح تسهیم راز Shamir است.
\end{itemize}

 \subsubsection*{کد پیاده‌سازی}
 کد پیاده‌سازی طرح تسهیم راز Shamir به‌صورت کامل در بخش سوال عملی دوم آورده شده است. این کد شامل توابع محاسبه معکوس ماژولی، ایجاد چندجمله‌ای، ارزیابی چندجمله‌ای، تقسیم راز به سهم‌ها و بازسازی راز از طریق تداخل لگرانژ می‌باشد.

 \subsection*{بخش چهارم: نتیجه‌گیری}

 در این گزارش، به حل سوالات نظری و عملی مرتبط با پروتکل‌های امنیتی و طرح تسهیم راز پرداخته شد. در بخش نظری، مفاهیم اساسی TLS و DTLS، حملات Downgrade و روش‌های مقابله با آن‌ها، گواهی‌های ریشه و نقش Samy Kamkar مورد بررسی قرار گرفتند. در بخش عملی، طرح تسهیم راز Shamir به‌طور کامل پیاده‌سازی و تست شد و نتایج نشان‌دهنده صحت و قابلیت اطمینان این طرح بود.

 طرح تسهیم راز Shamir به عنوان یک روش مؤثر برای محافظت از اطلاعات حساس در شرایطی که نیاز به تقسیم‌سازی و توزیع اطلاعات میان چندین نهاد وجود دارد، بسیار کاربردی و مؤثر می‌باشد. این طرح با استفاده از مفاهیم ریاضی پایه، امنیت بالایی را فراهم می‌کند و از دسترسی غیرمجاز به راز اصلی جلوگیری می‌کند.

 \subsection*{بخش پنجم: توابع مهم پیاده‌سازی}
 در این بخش، به توضیح توابع کلیدی پیاده‌سازی در کد Python پرداخته می‌شود.

 \subsubsection*{تابع \lr{mod\_inv(a, p)}}
 این تابع معکوس ماژولی عدد `a` را در میدان عددی `p` محاسبه می‌کند. از قضیه کوچک فرما برای محاسبه معکوس ماژولی استفاده شده است.

 \subsubsection*{تابع \lr{generate\_polynomial(secret, threshold, prime)}}
 این تابع یک چندجمله‌ای با درجه `threshold - 1` ایجاد می‌کند که ضریب آزاد آن برابر راز (`secret`) است و بقیه ضرایب به صورت تصادفی انتخاب می‌شوند.

 \subsubsection*{تابع \lr{evaluate\_polynomial(coefficients, x, prime)}}
 این تابع مقدار `y` را برای یک مقدار خاص `x` در چندجمله‌ای داده شده محاسبه می‌کند.

 \subsubsection*{تابع \lr{split\_secret(secret, n, threshold, prime)}}
 این تابع راز را به `n` سهم تقسیم می‌کند که هر سهم شامل یک عدد `x` و مقدار `y` است. حداقل `threshold` سهم برای بازسازی راز نیاز است.

 \subsubsection*{تابع \lr{reconstruct\_secret(shares, prime)}}
 این تابع راز اصلی را از طریق سهم‌ها با استفاده از تداخل لگرانژ بازسازی می‌کند. حداقل `threshold` سهم برای بازسازی راز لازم است.

 \subsection*{بخش ششم: چالش‌ها و راهکارها}
 در فرآیند پیاده‌سازی طرح تسهیم راز Shamir، با چالش‌های مختلفی مواجه شدیم که مهم‌ترین آن‌ها عبارت بودند از:

 \begin{itemize}
	     \item \textbf{انتخاب و تنظیمات صحیح عدد اول بزرگ:} انتخاب عدد اول مناسب که بزرگ‌تر از راز باشد و عملیات ریاضی در آن صحیح انجام شود از چالش‌های اصلی بود. استفاده از اعداد اول بزرگ مانند اعداد Mersenne به دلیل ساده بودن محاسبات و امنیت بالا، انتخاب مناسبی بودند.
	
	     \item \textbf{پیاده‌سازی صحیح تداخل لگرانژ:} اطمینان از صحت پیاده‌سازی روش تداخل لگرانژ برای بازسازی راز نیازمند درک عمیق از مفاهیم ریاضی پایه بود. تست‌های متعدد با داده‌های مختلف به ما کمک کرد تا از صحت عملکرد کد اطمینان حاصل کنیم.
	
	     \item \textbf{مدیریت حافظه و کارایی:} برای رازهای بسیار بزرگ، مدیریت حافظه و بهینه‌سازی عملکرد پیاده‌سازی ضروری بود. استفاده از روش‌های بهینه‌سازی و کاهش پیچیدگی محاسباتی به بهبود کارایی کمک کرد.
	 \end{itemize}

 \textbf{راهکارهای مقابله با چالش‌ها:}
 \begin{itemize}
	     \item \textbf{مطالعه دقیق نظریه پشت طرح \lr{Shamir}:} برای درک بهتر از مفاهیم و الگوریتم‌های مورد استفاده، مطالعه منابع معتبر در زمینه نظریه اشکال و رمزنگاری بسیار مؤثر بود.
	
	     \item \textbf{تست‌های جامع و متعدد:} اجرای تست‌های متعدد با داده‌های مختلف برای اطمینان از صحت عملکرد کد و بازسازی صحیح راز.
	
	     \item \textbf{بهینه‌سازی کد:} استفاده از روش‌های بهینه‌سازی در پیاده‌سازی کد برای کاهش زمان اجرای برنامه و مدیریت بهتر حافظه.
	 \end{itemize}

 \subsection*{بخش هفتم: پیشنهادات}

 برای بهبود عملکرد و افزایش دقت طرح تسهیم راز Shamir، پیشنهاد می‌شود:

 \begin{itemize}
	     \item \textbf{افزایش تعداد سهم‌های تست شده:} افزایش تعداد سهم‌های تست شده به بیش از ۱۰ سهم برای ارزیابی بهتر و دقیق‌تر عملکرد طرح.
	
	     \item \textbf{استفاده از الگوریتم‌های جایگزین:} بررسی و مقایسه طرح‌های تسهیم راز مختلف مانند طرح‌های مبتنی بر کریپتوگرافی دیگر برای انتخاب بهترین گزینه بر اساس نیازهای امنیتی.
	
	     \item \textbf{بهینه‌سازی محاسبات ریاضی:} استفاده از کتابخانه‌های بهینه‌سازی‌شده برای انجام محاسبات ریاضی پیچیده و افزایش سرعت بازسازی راز.
	
	     \item \textbf{استفاده در کاربردهای عملی:} پیاده‌سازی این طرح در سیستم‌های واقعی برای حفاظت از کلیدهای رمزنگاری و اطلاعات حساس.
	 \end{itemize}

\end{document}
