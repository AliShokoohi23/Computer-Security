\documentclass{report}

\usepackage{enumitem}
\usepackage[outputdir=./]{minted}
\usepackage{amsmath}
\usepackage{hyperref}

\input{Boostan-UserManual}

\title{پیک ایریدیم}
\type{}
\author{
محمد مهدی اقدسی 400521081 \\
علی شکوهی 400521477 \\
دانیال یگانه 400522337
}

\begin{document}
\pagenumbering{gobble}
\Godpage
\logofile{Pictures/IUST_logo_color.jpg}

\maketitle
\pagenumbering{arabic}
\tableofcontents

\chapter{سوالات تئوری}
\section{سوال اول}

در واقع، هیچ الگوریتم "سریع" شناخته شده ای برای فاکتورگیری اعداد صحیح بزرگ در یک کامپیوتر کلاسیک وجود ندارد. به همین دلیل است که فاکتورسازی اعداد صحیح یک مشکل محاسباتی سخت در نظر گرفته می‌شود و برای امنیت بسیاری از سیستم‌های رمزنگاری مانند RSA بسیار مهم است.
دشواری فاکتورگیری اعداد بزرگ از این واقعیت ناشی می شود که شناخته شده ترین الگوریتم ها در تعداد ارقام عدد فاکتورگیری شده زمان نمایی می گیرند.

پیچیدگی زمانی سریعترین الگوریتم شناخته شده برای فاکتورسازی اعداد صحیح به اعداد اول به اندازه عدد ورودی بستگی دارد. الگوریتم های مختلفی وجود دارند که برای اندازه های ورودی مختلف عملکرد بهتری دارند.
برای اعداد بسیار بزرگ (اعداد با صدها یا هزاران رقم)، سریعترین الگوریتم شناخته شده غربال میدان اعداد عمومی (GNFS) است. پیچیدگی زمانی الگوریتم GNFS برای فاکتورگیری یک عدد صحیح N برابر است با:
\[O(exp(((\frac{64}{9})^{\frac{1}{3}} + O(1)).(logN)^{1/3}.(log logN)^{2/3}))\]

این الگوریتم یک الگوریتم زیر نمایی می باشد که به طور قابل‌توجهی سریع‌تر از الگوریتم‌های صرفاً نمایی مانند تقسیم آزمایشی یا الگوریتم rho پولارد است. با این حال، GNFS هنوز از نظر محاسباتی فشرده است و برای اعداد کوچک‌تر کارایی کمتری دارد. برای اعداد با اندازه متوسط تر (تا چند صد رقم)، الگوریتم های دیگر مانند غربال درجه دوم (QS) یا روش منحنی بیضی (ECM) ممکن است در عمل سریعتر باشند، علیرغم داشتن پیچیدگی های زمانی مجانبی بدتر.
پیچیدگی زمانی الگوریتم غربال درجه دوم:
\[O(exp((1+O(1)).(lnN)^{1/2}.(lnlnN)^{1/2}))\]

مقالات مربوط به \lr{GNFS}:

\begin{latin}
\href{https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf}{Gasarch, W. (2005). A Beginner’s Guide To The General Number Field Sieve. University of Maryland.}

\href{https://personal.math.vt.edu/brown/doc/briggs_gnfs_thesis.pdf}{Briggs, M. (2001). An Introduction to the General Number Field Sieve. Virginia Tech.}
\end{latin}

\section{سوال دوم}

اعداد نیمه اول که با نام اعداد نیمه اول یا اعداد دو اول نیز شناخته می شوند، اعداد طبیعی هستند که دقیقا حاصل ضرب دو عدد اول مجزا هستند. به عبارت دیگر، یک عدد نیمه اول را می توان به صورت ضرب دو عدد اول مختلف بیان کرد.
به عنوان مثال، اعداد 6، 10، 14، 15، 21، 22، 26، 33، 34، 35، 38، 39، 51، 55، 57، 58، 62، 65، 69، 77، 85، 87 و 91 همه اعداد نیمه اول هستند زیرا می توان آنها را به عنوان حاصل ضرب دو عدد اول مجزا بیان کرد:
\begin{itemize}
    \item \lr{$3 \times 2 = 6$}
    \item \lr{$5 \times 2 = 10$}
    \item \lr{$7 \times 2 = 14$}
    \item \lr {$5 \times 3 = 15$}
    \item \lr{$7 \times 3 = 21$}
    \item ...
\end{itemize}
در مورد تجزیه اعداد نیمه اول به عوامل اول، به طور کلی ساده تر از تجزیه اعداد ترکیبی که نیمه اول نیستند در نظر گرفته می شود.
در اینجا دلیل آن است:
\begin{enumerate}
    \item تعداد محدود عامل اول: طبق تعریف، اعداد نیمه اول دقیقاً دو عامل اول مجزا دارند. این محدودیت فرآیند فاکتورسازی را در مقایسه با اعداد ترکیبی که ممکن است بیش از دو عامل اول داشته باشند، ساده می کند.
    \item الگوریتم های فاکتورسازی کارآمد: الگوریتم های کارآمدی وجود دارند که به طور خاص برای فاکتورگیری اعداد نیمه اول طراحی شده اند، مانند غربال درجه دوم و غربال فیلد اعداد. این الگوریتم‌ها از ساختار اعداد نیمه اول بهره می‌برند و فرآیند فاکتورسازی را کارآمدتر از اعداد مرکب عمومی می‌کنند.
    \item مبنای عامل کوچکتر: در زمینه الگوریتم های فاکتورسازی، پایه عامل (مجموعه اعداد اول کوچک مورد استفاده در الگوریتم) برای اعداد نیمه اول کوچکتر است زیرا عوامل به دو عدد اول محدود می شوند. این امر محاسبات را در مقایسه با اعداد مرکب با چندین عامل اول قابل کنترل تر می کند.
\end{enumerate}
در اینجا یک قیاس وجود دارد: تصور کنید یک کیسه با چند تیله رنگی دارید. یافتن یک سنگ مرمر رنگی خاص (ضریب اصلی) در صورتی که سنگ مرمرهای زیادی وجود داشته باشد (عدد مرکب با فاکتورهای زیاد) می تواند دشوار باشد. اما، اگر کیسه فقط دو تیله داشته باشد (نیمه پرایم)، پیدا کردن یک سنگ مرمر رنگی خاص بسیار آسان تر می شود.
با این حال، توجه به این نکته مهم است که در حالی که فاکتورسازی اعداد نیمه اول به طور کلی ساده تر از اعداد مرکب عمومی است، مشکل همچنان با افزایش اندازه (تعداد ارقام) اعداد نیمه اول افزایش می یابد. اعداد نیمه اول بزرگ هنوز هم می توانند چالش های محاسباتی قابل توجهی برای الگوریتم های فاکتورسازی ایجاد کنند.
معمولاً تجزیه اعداد نیمه اول بسیار بزرگ به ضرایب اول دشوارتر از فاکتورگیری اعدادی است که اول هستند یا دارای عوامل اول کوچک هستند. این به این دلیل است که اعداد نیمه اول به طور خاص به عنوان حاصل ضرب دو عدد اول بزرگ انتخاب می شوند و هیچ الگوریتم کارآمد شناخته شده ای وجود ندارد که آنها را به طور کلی عامل بندی کند.

به عبارت دیگر، تجزیه اعداد نیمه اول بسیار بزرگ زمانی که دو عدد اول بسیار بزرگ و تصادفی انتخاب شده و دارای مقدار نسبتا نزدیک هستند، حتی سریع ترین الگوریتم ها در سریع ترین کامپیوترها آنقدر زمان می برند که در واقع ناکارآمد هستند.
به طور خلاصه، اعداد نیمه اول، اعداد مرکبی هستند که حاصل ضرب دو عدد اول مجزا هستند، و تجزیه آنها به ضرایب اول آنها معمولا ساده‌تر از تجزیه اعداد ترکیبی که نیمه اول نیستند، به دلیل تعداد محدود عوامل اول و در دسترس بودن کارآمد است. الگوریتم های فاکتورسازی که به طور خاص برای اعداد نیمه اول طراحی شده اند. اما با افزایش اندازه اعداد اول، فاکتورگیری اعداد نیمه اول به طور تصاعدی دشوارتر می شود و به طور فزاینده ای به چالش کشیدن آنها تبدیل می شود. این دشواری در طرح‌های رمزنگاری مختلف، مانند RSA، که بر مشکل فاکتورگیری اعداد نیمه‌اول بزرگ برای امنیت خود متکی هستند، استفاده می‌شود.

\section{سوال سوم}

در اصل، شرط اول بودن m نسبت به n یک شرط قوی است که عمدتاً برای اطمینان از یکپارچگی ریاضی عملیات رمزنگاری استفاده می‌شود، اما برای عملکرد الگوریتم RSA کاملاً ضروری نیست به شرطی که دو عدد اول انتخاب شده با یکدیگر یکسان نباشند. در اکثر مواقع، m به طور طبیعی نسبت به n به دلیل نحوه ساختن n (به عنوان حاصل ضرب دو عدد اول بزرگ) اول خواهد بود، اما چنین شرطی ضروری نیست.

در مقاله اصلی RSA نیز در بخش \lr{VI The Underlying Mathematics} این قضیه اثبات می شود. 

لینک به سوال مربوط در سایت \lr{crypto.stackexchange.com} (اثبات‌های مختلفی از این قضیه در پاسخ‌ها وجود دارد):
\href{https://crypto.stackexchange.com/questions/1004/does-rsa-work-for-any-message-m/}{سوال}

مرجع به بخش اثبات ریاضیاتی در مقاله اصلی \lr{RSA} :
\href{https://people.csail.mit.edu/rivest/Rsapaper.pdf#page=7}{اثبات}

\section{سوال چهارم}

در الگوریتم \lr{RSA} بهتر است پارامتر \( e \) فرد باشد تا زوج. این به این دلیل است که \( e \) باید نسبت به \( \varphi(n) \) اول باشد، که در آن \( \varphi(n) = (p-1)(q-1) \). از آنجایی که \( \varphi(n) \) همیشه زوج است (چرا که هر دو \( p-1 \) و \( q-1 \) زوج هستند)، \( e \) زوج نسبت به \( \varphi(n) \) اول نخواهد بود، مگر اینکه 1 باشد، که برای رمزگذاری مناسب نیست. به طور معمول، مقادیر کوچک فرد اول مانند 3، 17، یا 65537 برای \( e \) انتخاب می‌شوند، زیرا برای رمزگذاری کارآمد هستند و اطمینان می‌دهند که بزرگترین مقسوم‌کننده مشترک با \( \varphi(n) \) برابر با 1 است.

\section{سوال پنجم}

اعداد فرما دنباله‌ای خاص از اعداد هستند که با فرمول زیر تعریف می‌شوند:

\[ F_n = 2^{2^n} + 1 \]

که در آن \( n \) یک عدد صحیح غیرمنفی است. چند عدد اول فرما عبارتند از:
\begin{align*}
    F_0 &= 3 \\
    F_1 &= 5 \\
    F_2 &= 17 \\
    F_3 &= 257 \\
    F_4 &= 65537
\end{align*}

\subsection*{نقش اعداد فرما در تولید پارامتر RSA}
در الگوریتم \lr{RSA}، انتخاب توان عمومی \( e \) به عنوان یک عدد فرما، به ویژه \( F_4 = 65537 \)، رایج است. این انتخاب مطلوب است زیرا:

\begin{enumerate}
    \item
    \textbf{کارایی}:
     استفاده از 65537 (که \( 2^{16} + 1 \) است) به عنوان \( e \) رمزگذاری کارآمد و تأیید امضا را به دلیل وزن کم همینگ آن تضمین می‌کند (یعنی فقط دو بیت 1 در نمایش باینری خود دارد).

    \item
    \textbf{ضرورت}:
     اعداد فرما که اعداد اول نسبتاً بزرگ هستند، خاصیت لازم را حفظ می‌کنند که \( e \) نسبت به \( \varphi(n) \) هم‌اول باشد.

    \item
    \textbf{اعداد فرد}:
     این اعداد، اعداد فرد هستند و ما ترجیح می‌دهیم \( e \) فرد باشد همانطور که در سوال قبلی بیان شد.

\end{enumerate}

بنابراین، به طور خلاصه، در حالی که این انتخاب مورد نیاز نیست، استفاده از یک عدد اول فرما مانند 65537 به عنوان توان عمومی \( e \) در RSA یک روش توصیه‌شده است. این انتخاب تعادلی بین کارایی محاسباتی و امنیت برقرار می‌کند و آن را به یک انتخاب محبوب در پیاده‌سازی RSA تبدیل می‌کند.

\section{سوال ششم}

مقاله RSA چندین الگوریتم کارآمد را برای انجام توان مدولار، \(M^e \mod n\) و \(C^d \mod n\) در طول رمزگذاری و رمزگشایی به ترتیب مورد بحث قرار می‌دهد. در اینجا برخی از الگوریتم های بهینه شده تحت پوشش آورده شده است:

\begin{enumerate}
    \item
    توان با مربع و ضرب مکرر (بخش \lr{VII.A}):
    این یک الگوریتم اساسی است که در مقاله ارائه شده است. وقتی بیت متناظر در نمایش دودویی \(e\) 1 باشد، \(M^e \mod n\) را با مجذور کردن مکرر \(M\) و ضرب در \(M\) محاسبه می کند. پیچیدگی زمانی آن \(O(\log e)\) است.
    
    \item 
    رویه های کارآمدتر (بخش \lr{VII.A}):
    این مقاله اشاره می‌کند که روش‌های کارآمدتری نسبت به مربع‌سازی مکرر پایه شناخته شده‌اند، بدون اینکه وارد جزئیات شوند. برخی از نمونه ها عبارتند از:
    \begin{itemize}
        \item
            توان پنجره کشویی: توان های کوچک را از قبل محاسبه می کند تا دوباره استفاده کند و سرعت را افزایش دهد.
        \item 
            توان زنجیره جمع: \(M^e\) را با استفاده از یک زنجیره جمع برای \(e\) محاسبه می کند.
    \end{itemize}

    \item 
    الگوریتم های مطالعه شده توسط \lr{Knuth} (بخش \lr{VII.A}):
    این مقاله به کار اصلی کنوت «هنر برنامه‌نویسی رایانه‌ای» اشاره می‌کند که الگوریتم‌های توان را با جزئیات مورد مطالعه قرار می‌دهد، از جمله:
    \begin{itemize}
        \item
        توان دودویی
        \item 
        استفاده از زنجیر اضافه
        \item 
        بهره برداری از الگوهای توان ویژه
        \item 
        ضریب معاملاتی برای تربیع
    \end{itemize}

    \item 
    الگوریتم ضرب مونتگومری:
    اگرچه به صراحت در مقاله اصلی RSA ذکر نشده است، روش ضرب مونتگومری یک تکنیک بهینه برای انجام ضرب‌های مدولار در طول توان است، و از عملیات تقسیم پرهزینه جلوگیری می کند.

    \item 
    کاهش بارت:
    این تکنیک کارایی گام کاهش مدولار را در طول توان بهبود می بخشد. مقادیری را از پیش محاسبه می‌کند که به کاهش مدولار اجازه می‌دهد با استفاده از ضرب و تفریق انجام شود و از تقسیم اجتناب شود.
\end{enumerate}

این تکنیک‌ها، همراه با سایر روش‌های پیشرفته مانند استفاده از سخت‌افزار محاسباتی مدولار، می‌توانند به طور قابل‌توجهی عملیات توان‌سازی مدولار هسته را در RSA، که فشرده‌ترین بخش‌های محاسباتی آن هستند، بهینه کنند. الگوریتم‌های بهینه‌سازی قدرت برای پیاده‌سازی RSA با کارایی بالا بسیار مهم هستند.

\section{سوال هفتم}

مقایسه سطح امنیتی اندازه‌های کلید RSA با اندازه‌های کلید متقارن برای رمزهای بلوکی به شرح زیر است:
\begin{itemize}
    \item 
    یک کلید RSA 1024 بیتی تقریباً به اندازه یک کلید متقارن 80 بیتی مانند \lr{2TDEA} امنیت دارد.
    \item
    یک کلید RSA 2048 بیتی تقریباً به اندازه یک کلید متقارن 112 بیتی مانند \lr{3TDEA} امنیت دارد.
\end{itemize}

باید توجه داشت که این‌ها تنها تخمین‌هایی هستند و مفروضات پیچیدگی محاسباتی و مدل‌های حمله برای سیستم‌های رمزنگاری کلید عمومی مانند RSA با رمزهای بلوکی متفاوت است. اما این تخمین‌ها یک حس کلی از سطوح امنیتی مورد هدف برای اندازه‌های مختلف کلید RSA در مقایسه با رمزهای بلوکی ارائه می‌دهد.

مرجع:
\begin{latin}
\href{https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf}{Barker, Elaine (May 2020). "Recommendation for Key Management: Part 1 – General" (PDF), Page 54. NIST Special Publication.} 
\end{latin}

\section{سوال هشتم}

تولید اعداد اول مناسب برای \lr{RSA} شامل چندین مرحله برای اطمینان از ایمن بودن و مناسب بودن اعداد برای استفاده رمزنگاری است:

\begin{enumerate}
    \item
    انتخاب تصادفی نامزدها
    \begin{itemize}
        \item 
        طول بیت: طول بیت اول را انتخاب میکنیم (به عنوان مثال، ۱۰۲۴ بیت برای کلیدهای ۲۰۴۸ بیتی \lr{RSA}).
        
        \item 
        تولید عدد تصادفی: یک عدد تصادفی از طول بیت مورد نظر را ایجاد کنید. مطمئن شوید که فرد است (زیرا اعداد زوج بزرگتر از ۲ اول نیستند).
    \end{itemize}
    
    \item
    تست اولیه
    \begin{itemize}
        \item 
        تست های پایه: بررسی های اولیه مانند تقسیم پذیری بر اعداد اول کوچک را انجام دهید تا سریعاً اعداد غیر اول را رد کنیم.
        \item 
        تست های اولیه احتمالی: از آزمون هایی مانند آزمون \lr{Miller-Rabin} یا آزمون \lr{Baillie-PSW} برای تعیین اینکه آیا عددی با احتمال زیاد اول است یا خیر، استفاده میکنیم. چندین دور را تکرار میکنیم تا شانس مثبت کاذب را کاهش دهیم
    \end{itemize}
    
    \item 
    تضمین امنیت رمزنگاری
    \begin{itemize}
        \item 
        راندهای کافی(\lr{Sufficient Rounds}): برای \lr{Miller-Rabin}، از دورهای کافی (مثلاً 40 برای امنیت بالا) استفاده میکنیم تا به سطح اطمینان مطلوبی دست یابید.
        \item 
        اجتناب از عوامل کوچک(\lr{Avoiding Small Factors}): اطمینان حاصل میکنیم که اعداد اول خیلی به توان های اعداد اول کوچک نزدیک نیست تا از حملات رمزنگاری خاص جلوگیری شود.
    \end{itemize}

    \item 
    تایید و اعتبار سنجی
    \begin{itemize}
        \item
        منحصر به فرد و به اندازه کافی بزرگ: مطمئن میشویم که اعداد اول p و q متمایز و به اندازه کافی بزرگ هستند تا حاشیه امنیتی لازم را فراهم کنند.

        \item
        معیارهای اضافی: به صورت اختیاری، ویژگی های اضافی مانند p-1 یا q-1 را که دارای فاکتورهای اصلی بزرگ برای افزایش امنیت هستند، بررسی میکنیم.
    \end{itemize}
\end{enumerate}

مثالی از این فرآیند:
\begin{enumerate}
    \item
    ایجاد نامزد:
    \begin{itemize}
        \item 
        یک عدد فرد تصادفی 1024 بیتی ایجاد میکنیم.
    \end{itemize}

    \item
    بررسی اولیه:
    \begin{itemize}
        \item 
        بررسی میکنیم که آیا عدد بر هر عدد اول کوچک بخش پذیر است (مثلاً تا 1000).
    \end{itemize}

    \item
    تست اولیه:
    \begin{itemize}
        \item 
        آزمون \lr{Miller-Rabin} را برای 40 تکرار اعمال میکنیم.
    \end{itemize}

    \item
    تکرار:
    \begin{itemize}
        \item 
        اگر عدد تمام تست ها را پشت سر بگذارد، احتمالاً اول است. در غیر این صورت، یک نامزد جدید ایجاد میکنیم و تکرار میکنیم.
    \end{itemize}
\end{enumerate}

تضمین امنیت تولید اعداد اول:
\begin{itemize}
    \item 
    از مولدهای اعداد تصادفی امن رمزنگاری شده (\lr{CSPRNG}) استفاده کنیم.
    
    \item
    اعتبار اجرا را بر اساس استانداردهای شناخته شده (به عنوان مثال، \lr{FIPS 186-4}).
\end{itemize}

کتابخانه ها و ابزارها:
\begin{itemize}
    \item 
    کتابخانه های رمزنگاری مانند \lr{OpenSSL} و \lr{GNU MP} (\lr{GMP}) توابع داخلی را برای تولید و آزمایش اعداد اول بزرگ ارائه می کنند و از تولید اعداد اول قابل اعتماد و کارآمد برای RSA اطمینان حاصل می کنند.
\end{itemize}

الگوریتم های احتمالی تولید اعداد اول احتمال زیادی برای تولید یک عدد اول در یک محدوده مشخص ارائه می کنند، اما ممکن است گاهی اوقات اعداد ترکیبی تولید کنند. این الگوریتم ها اغلب برای آزمایش اولیه یا زمانی که سرعت بر قطعیت مطلق اولویت دارد استفاده میشود.
الگوریتم های رایج احتمالی تولید اعداد اول عبارتند از:
\begin{itemize}
    \item \lr{Miller-Rabin}
    \item \lr{Probabilistic Lucas}
\end{itemize}

همچنین باید در نظر داشت که در حالت کلی الگوریتم های تولید اعداد اول به دو دسته تقسیم می شوند: الگوریتم های احتمالی و قطعی

الگوریتم های تولید اعداد اول قطعی تضمین می کنند که خروجی یک عدد اول است، اما آنها اغلب کندتر از الگوریتم های احتمالی هستند. این الگوریتم ها معمولا بر ویژگی های ریاضی خاص اعداد اول تکیه می کنند و ممکن است محاسبات پیچیدەتر و زمان طولانی تری را شامل شوند. الگوریتم های متداول تولید اعداد اول قطعی عبارتند از:
\begin{itemize}
    \item \lr{Pollard’s rho algorithm}
    \item \lr{Sieve of Eratosthenes}
\end{itemize}

\section{سوال نهم}

\subsection*{مقدمه}
اثبات دانایی صفر \lr{(Zero-Knowledge Proofs)} روش‌های رمزنگاری هستند که به یک طرف (اثبات‌کننده) اجازه می‌دهند تا به طرف دیگر (تأییدکننده) ثابت کند که مقداری را می‌داند، بدون اینکه هیچ اطلاعاتی در مورد آن مقدار فاش کند. اثبات دانایی صفر غیرتعاملی \lr{(Non-Interactive Zero-Knowledge Proofs)} نوعی هستند که تعامل بین اثبات‌کننده و تأییدکننده به حداقل می‌رسد، معمولاً فقط یک پیام از اثبات‌کننده به تأییدکننده.

یکی از معروف‌ترین NIZKPs مورد استفاده در فناوری زنجیره بلوکی، 
\lr{\textbf{zk-SNARKs}}
یا
\lr{Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge}
است.

\subsection*{اجزای zk-SNARKs}
اجزای اصلی zk-SNARKs عبارتند از:
\begin{enumerate}
    \item \textbf{زبان بیانی}: توصیف مسئله‌ای که باید اثبات شود.
    \item \textbf{تنظیمات اولیه \lr{(Setup Phase)}}: تولید پارامترهای عمومی و خصوصی.
    \item \textbf{ساخت اثبات \lr{(Proof Generation)}}: اثبات دانایی بدون افشای اطلاعات.
    \item \textbf{تأیید اثبات \lr{(Proof Verification)}}: تأیید اعتبار اثبات بدون نیاز به تعامل.
\end{enumerate}

\subsection*{توضیح فرآیند}
فرآیند zk-SNARKs را می‌توان به مراحل زیر تقسیم کرد:

\subsubsection*{تنظیمات اولیه \lr{(Setup Phase)}}
\begin{itemize}
    \item یک الگوریتم راه‌اندازی وجود دارد که دو مجموعه پارامتر تولید می‌کند: پارامترهای عمومی و پارامترهای خصوصی.
    \item پارامترهای عمومی به‌طور عمومی منتشر می‌شوند و برای ساخت و تأیید اثبات‌ها استفاده می‌شوند.
    \item پارامترهای خصوصی مخفی نگه داشته می‌شوند و تنها برای اطمینان از امنیت پروتکل ضروری هستند.
\end{itemize}

\subsubsection*{ساخت اثبات \lr{(Proof Generation)}}
\begin{itemize}
    \item اثبات‌کننده با استفاده از پارامترهای عمومی و دانش مخفی خود، یک اثبات غیرتعاملی تولید می‌کند.
    \item این اثبات شامل یک رشته کوتاه از داده‌ها است که ثابت می‌کند اثبات‌کننده واقعاً دانش مخفی مورد نیاز را دارد، بدون اینکه آن دانش را فاش کند.
\end{itemize}

\subsubsection*{تأیید اثبات \lr{(Proof Verification)}}
\begin{itemize}
    \item تأییدکننده با استفاده از پارامترهای عمومی و اثبات تولید شده، می‌تواند صحت اثبات را تأیید کند.
    \item تأیید اثبات بسیار سریع است و نیازی به تعامل با اثبات‌کننده ندارد.
\end{itemize}

\subsection*{کاربرد در زنجیره بلوکی}
\begin{itemize}
    \item \textbf{حفظ حریم خصوصی}:
     در ارزهای رمزنگاری شده مانند \lr{Zcash}، از \lr{zk-SNARKs} برای مخفی‌سازی جزئیات تراکنش‌ها (مانند فرستنده، گیرنده و مقدار تراکنش) استفاده می‌شود.
    \item \textbf{کاهش بار محاسباتی}:
     تأیید تراکنش‌ها به‌صورت غیرتعاملی و سریع انجام می‌شود، که می‌تواند بار محاسباتی را کاهش دهد و به مقیاس‌پذیری شبکه کمک کند.
\end{itemize}

\subsection*{مثال کاربردی}
فرض کنید یک فرستنده می‌خواهد اثبات کند که یک مقدار خاص از ارز رمزنگاری شده را دارد و می‌تواند آن را به گیرنده منتقل کند، بدون اینکه جزئیات تراکنش (مانند مقدار دقیق) را فاش کند. با استفاده از \lr{zk-SNARKs}، فرستنده می‌تواند اثبات کند که تراکنش معتبر است، در حالی که اطلاعات حساس مخفی باقی می‌مانند. گیرنده و سایر اعضای شبکه می‌توانند به راحتی و بدون نیاز به تعامل با فرستنده، صحت این اثبات را تأیید کنند.

\subsection*{نتیجه‌گیری}
zk-SNARKs به عنوان یک ابزار قدرتمند در زنجیره بلوکی برای ایجاد تراکنش‌های امن و خصوصی به‌کار گرفته می‌شوند، و به افزایش اعتماد و کارایی در سیستم‌های غیرمتمرکز کمک می‌کنند.

\section{سوال دهم}

\subsection*{الگوریتم کلید نامتقارن رابین (۱۹۷۹)}
    الگوریتم کلید نامتقارن \textbf{رابین} توسط \textbf{مایکل او. رابین} در سال ۱۹۷۹ ارائه شد. این الگوریتم بر مبنای دشواری \textbf{فاکتورگیری} (تجزیه به عوامل اول) طراحی شده است و به عنوان یکی از اولین الگوریتم‌های رمزنگاری کلید عمومی محسوب می‌شود.
    
\subsubsection*{مفاهیم کلی}
    الگوریتم رابین از ویژگی‌های \textbf{اعداد اول} و \textbf{محاسبه جذر} به صورت پیمانه‌ای استفاده می‌کند. امنیت این الگوریتم به سختی فاکتورگیری عدد مرکب \( n \) بستگی دارد، که از حاصل‌ضرب دو عدد اول بزرگ \( p \) و \( q \) به دست می‌آید.
    
\subsection*{مراحل الگوریتم}

\subsubsection*{۱. تولید کلیدها}

\begin{enumerate}
    \item دو عدد اول بزرگ \( p \) و \( q \) انتخاب کنید به طوری که هر دو به پیمانه ۴ با عدد ۳ هم‌نهشت باشند:
    \[
    p \equiv 3 \pmod{4}, \quad q \equiv 3 \pmod{4}.
    \]
    \item مقدار \( n \) را به صورت زیر محاسبه کنید:
    \[
    n = p \times q.
    \]
    \item کلید عمومی \textbf{\( n \)} است و کلید خصوصی شامل \( p \) و \( q \) می‌شود.
\end{enumerate}

\subsubsection*{۲. رمزگذاری}

\begin{enumerate}
    \item فرض کنید \( M \) یک پیام به شکل عددی باشد که \( M < n \).
    \item برای رمزگذاری پیام، مقدار \( C \) را به صورت زیر محاسبه کنید:
    \[
    C = M^2 \pmod{n}.
    \]
    \item \( C \) متن رمز شده است.
\end{enumerate}

\subsubsection*{۳. رمزگشایی}

\begin{enumerate}
    \item برای رمزگشایی \( C \)، نیاز به مقادیر خصوصی \( p \) و \( q \) داریم.
    \item از الگوریتم \textbf{چینی باقیمانده} (CRT) برای محاسبه جذرهای \( C \) به پیمانه \( p \) و \( q \) استفاده می‌کنیم.
    \item چهار مقدار ممکن به عنوان جذر \( C \) وجود دارد. یکی از این مقادیر همان پیام اصلی \( M \) است.
\end{enumerate}

\subsection*{ویژگی‌های الگوریتم}

\begin{itemize}
    \item امنیت این الگوریتم به طور مستقیم به \textbf{دشواری فاکتورگیری} عدد \( n \) وابسته است.
    \item رمزگذاری در این الگوریتم بسیار سریع است؛ زیرا شامل یک \textbf{عملیات مربع کردن} ساده به پیمانه \( n \) می‌شود.
    \item رمزگشایی پیچیده‌تر از رمزگذاری است، زیرا باید چهار جذر مختلف را محاسبه و بررسی کرد.
    \item یکی از چالش‌های این الگوریتم، تولید \textbf{چهار جذر ممکن} در فرآیند رمزگشایی است، که نیازمند حل ابهام برای یافتن پیام صحیح می‌باشد.
\end{itemize}

\section{سوال یازدهم}

الگوریتم \textbf{امضای دیجیتال \lr{DSA}} (\lr{Digital Signature Algorithm}) که در سال ۱۹۹۱ توسط \lr{NIST} پیشنهاد و بعدها در قالب استاندارد \lr{FIPS 186-1} منتشر شد، مبتنی بر مفاهیم گروه‌های انتخابی و توابع گسسته لگاریتم است. این الگوریتم در سه مرحله‌ی کلی کار می‌کند: تولید کلید، امضا کردن پیام، و در نهایت راستی‌آزمایی (تأیید) امضا. مراحل امضای پیام به‌صورت زیر خلاصه می‌شود:

\begin{enumerate}
    \item \textbf{تولید پارامترها و کلیدها:}
    \begin{itemize}
        \item ابتدا پارامترهای اصلی الگوریتم (شامل اعداد اول و پایه‌ی مولد) توسط یک مرجع یا کاربر تولید می‌شود. این پارامترها را می‌توان در سطح سیستم یا برای هر کاربر مجزا تولید کرد.
        \item هر کاربر یک کلید خصوصی و متناظر با آن یک کلید عمومی خواهد داشت. کلید خصوصی عددی تصادفی و کم‌حجم (نسبت به اندازه‌ی ماژول اصلی) است و کلید عمومی با استفاده از یک تابع توان (ماژولار) از کلید خصوصی محاسبه می‌شود.
    \end{itemize}
    
    \item \textbf{تولید امضا:}
    \begin{itemize}
        \item فرستنده ابتدا پیام خود را توسط یک تابع درهم‌ساز (\lr{Hash}) نظیر \lr{SHA-1} یا \lr{SHA-2} خلاصه می‌کند تا هش پیام به‌دست آید.
        \item برای هر امضاکردن، یک عدد تصادفی موقتی (مثلاً $k$) انتخاب می‌شود. سپس با استفاده از این عدد تصادفی و پارامترهای عمومی، مؤلفه‌ی اول امضا (معمولاً با $r$ نمایش داده می‌شود) تولید می‌گردد.
        \item مؤلفه‌ی دوم امضا (معمولاً $s$) نیز با درنظرگرفتن کلید خصوصی فرستنده، هش پیام، و همان عدد تصادفی $k$ (به‌صورت وارون ماژولار) به‌دست می‌آید.
        \item در نهایت جفت $(r, s)$ به‌عنوان امضای دیجیتال پیام ارسال می‌شود.
    \end{itemize}
    
    \item \textbf{تأیید امضا:}
    \begin{itemize}
        \item گیرنده ابتدا پارامترهای عمومی فرستنده (شامل کلید عمومی او) و امضای دریافت‌شده $(r, s)$ را استخراج می‌کند.
        \item با محاسبه‌ی دوباره‌ی هش پیام و انجام محاسباتی شامل $r$, $s$ و کلید عمومی فرستنده، گیرنده تأیید می‌کند که این امضا صحیح است یا خیر.
        \item اگر نتیجه با $r$ دریافت‌شده یکسان باشد، امضا معتبر خواهد بود؛ در غیر این صورت امضا رد می‌شود.
    \end{itemize}
\end{enumerate}

\section{سوال دوازدهم}

امروزه نسخه‌های بیضوی از الگوریتم‌های مبتنی بر \lr{DH} (\lr{Diffie-Hellman})، بسیار پرکاربرد هستند. این الگوریتم‌ها در حوزه‌ی رمزنگاری با خم‌های بیضوی (\lr{Elliptic Curves}) عمل می‌کنند که امنیت بالاتر و اندازه‌ی کلید کوچک‌تری نسبت به روش‌های قدیمی‌تر (مانند \lr{RSA}) دارند. ایده‌ی کلی مبتنی بر سختیِ مسئله‌ی \textbf{لگاریتم گسسته} در گروه نقاط یک خم بیضوی است:

\begin{itemize}
    \item
     در فضای خم بیضوی، یک نقطه‌ی پایه (Generator) انتخاب می‌شود. هر کاربر یک عدد تصادفی کوچک (نسبت به مرتبه‌ی خم) به‌عنوان کلید خصوصی تولید می‌کند و با ضرب اسکالر آن عدد در نقطه‌ی پایه، کلید عمومی خود را به‌دست می‌آورد.
    \item
     در تبادل کلید \lr{ECC-DH}، اگر کاربر اول عدد خصوصی $d_A$ و نقطه‌ی عمومی $Q_A = d_A G$ داشته باشد و کاربر دوم هم عدد خصوصی $d_B$ و نقطه‌ی عمومی $Q_B = d_B G$، آنگاه کلید مشترک با محاسبه‌ی $d_A Q_B$ یا $d_B Q_A$ به‌دست می‌آید. این دو مقدار (در ریاضیات خم بیضوی) برابر هستند و عملاً راز مشترک طرفین محسوب می‌شوند.
\end{itemize}

\noindent\textbf{مثال ساده:}
\begin{enumerate}
    \item \textbf{کاربر اول} (آلیس) کلید خصوصی $d_A$ را برمی‌گزیند و کلید عمومی‌اش را به‌شکل $Q_A = d_A G$ می‌سازد.
    \item \textbf{کاربر دوم} (باب) هم کلید خصوصی $d_B$ و کلید عمومی $Q_B = d_B G$ را تولید می‌کند.
    \item آلیس پس از دریافت $Q_B$، نقطه‌ی $d_A Q_B$ را محاسبه می‌کند.
    \item باب نیز پس از دریافت $Q_A$، نقطه‌ی $d_B Q_A$ را محاسبه می‌کند.
    \item طبق خواص گروه خم بیضوی، داریم:
    \[
    d_A Q_B = d_A (d_B G) = d_B (d_A G) = d_B Q_A,
    \]
    که همان کلید اشتراکی نهایی بین آن‌هاست.
\end{enumerate}

\section{سوال سیزدهم}

\textbf{طاهر الجمال} (\lr{Taher Elgamal}) الگوریتمی مبتنی بر \lr{DH} را در سال ۱۹۸۴ ارائه داد که بعدها با نام \textbf{الگوریتم الگمال} (\lr{ElGamal}) شناخته شد. این روش یک رمزنگاری نامتقارن (کلید عمومی) است. ایده‌ی اصلی آن به شرح زیر است:

\begin{itemize}
    \item بر روی یک گروه با عمل ضربی (یا جمعی در خم‌های بیضوی) کار می‌کنیم که \textbf{لگاریتم گسسته} در آن دشوار است.
    \item شخص گیرنده (مثلاً باب) یک کلید خصوصی $x$ برمی‌گزیند و با یک پارامتر عمومی $g$ (پایه) و عدد اول بزرگ $p$ (ماژول اصلی)، کلید عمومی‌اش را $y = g^x \bmod p$ منتشر می‌کند.
    \item فرستنده (مثلاً آلیس)، برای رمزکردن پیام $M$:
    \begin{enumerate}
        \item یک عدد تصادفی $k$ انتخاب می‌کند.
        \item کامپوننت اول متن رمز را $c_1 = g^k \bmod p$ می‌سازد.
        \item کامپوننت دوم متن رمز را $c_2 = M \times (y^k \bmod p)$ می‌سازد.
        \item متن رمز را به‌شکل جفت $(c_1, c_2)$ به باب ارسال می‌کند.
    \end{enumerate}
    \item باب برای رمزگشایی از کلید خصوصی $x$ استفاده می‌کند و از طریق محاسبه‌ی $(c_1)^x \bmod p$ به مقدار مشترک $y^k$ دست می‌یابد و سپس $M = c_2 \times (c_1^x)^{-1} \bmod p$ را به‌دست می‌آورد.
\end{itemize}

\noindent\textbf{مثال ساده:}
\begin{enumerate}
    \item \textbf{تولید کلید:} 
    \begin{itemize}
        \item باب یک عدد اول بزرگ $p$ و پایه‌ی $g$ را انتخاب می‌کند.
        \item عدد خصوصی باب $x$ است و عدد عمومی او $y = g^x \bmod p$.
    \end{itemize}
    \item \textbf{رمزگذاری:} 
    \begin{itemize}
        \item آلیس پیام $M$ دارد.
        \item آلیس عدد تصادفی $k$ را برمی‌گزیند و $c_1 = g^k \bmod p$ را محاسبه می‌کند.
        \item سپس $c_2 = M \times (y^k \bmod p)$ را می‌سازد.
        \item بسته‌ی رمز را $(c_1,c_2)$ برای باب می‌فرستد.
    \end{itemize}
    \item \textbf{رمزگشایی:} 
    \begin{itemize}
        \item باب با استفاده از $x$ محاسبه می‌کند: 
        \[
        (c_1)^x \bmod p = (g^k)^x \bmod p = g^{kx} \bmod p = y^k.
        \]
        \item از آنجا که $c_2 = M \times y^k$ است، با ضرب در وارون $y^k$ در مد $p$ می‌تواند $M$ را بازیابی کند:
        \[
        M = c_2 \times (y^k)^{-1} \bmod p.
        \]
    \end{itemize}
\end{enumerate}

\section{سوال چهاردهم}

این دو عکس مربوط به افراد برجسته در حوزه امنیت هستند:
\begin{enumerate}
    \item \textbf{بروس اشنایر \lr{(Bruce Schneier)}:} بروس اشنایر یکی از متخصصین برجسته در حوزه امنیت سایبری و رمزنگاری است. او نویسنده کتاب‌ها و مقالات بسیاری در زمینه امنیت اطلاعات است. برخی از مهم‌ترین کتاب‌های او عبارتند از \textit{Applied Cryptography} و \textit{Secrets and Lies} که به موضوعات مختلف امنیت اطلاعات و تحلیل سیستم‌های امنیتی پرداخته است. مفاهیمی همچون \textit{Security Theater} (نمایش امنیت) که به اقدامات ناکارآمد امنیتی اشاره دارد، توسط او معرفی شده است. او الگوریتم‌های رمزنگاری \lr{Blowfish} و \lr{Twofish} را طراحی کرده است که در زمان خود بسیار مورد استفاده قرار گرفته‌اند. همچنین، او به‌طور گسترده درباره حفظ حریم خصوصی، امنیت در فضای دیجیتال، و مسائل امنیت سایبری بحث کرده و به عنوان یکی از منتقدان سرسخت نظارت گسترده دولت‌ها شناخته می‌شود.
    
    \item \textbf{رالف مرکل \lr{(Ralph Merkle)}:} رالف مرکل یکی از بنیان‌گذاران رمزنگاری کلید عمومی و از پیشگامان در علم رمزنگاری مدرن است. او به‌ویژه به دلیل توسعه \lr{Merkle Tree} (درخت مرکل) شناخته می‌شود. این ساختار داده‌ای برای تأیید یکپارچگی داده‌ها در سیستم‌های توزیع‌شده مانند بلاک‌چین و سیستم‌های همتا به همتا استفاده می‌شود. علاوه بر این، مرکل یکی از اولین افرادی بود که ایده رمزنگاری کلید عمومی را ارائه کرد. کارهای او پایه‌ای برای الگوریتم‌هایی مانند \lr{RSA} و \lr{Elliptic Curve Cryptography} بوده است. او همچنین در زمینه محاسبات کوانتومی و کاربردهای آن در رمزنگاری تحقیقات داشته است. دستاوردهای او نقش مهمی در توسعه فناوری‌های مدرن امنیت داده داشته است.
\end{enumerate}

\chapter{سوالات عملی}

\section{سوال اول}

\subsection*{بخش اول: محیط و ابزارهای مورد استفاده}

برای پیاده‌سازی محیط کاربری این برنامه از محیط توسعه \lr{Qt} با زبان \lr{C++} استفاده شده است. همچنین برای تامین امنیت و استفاده از رمزنگاری از موتور قدرتمند \lr{GnuPG} یا \lr{Gnu Privacy Guard} استفاده شده است. \lr{GnuPG} یک نرم‌افزار آزاد است که برای رمزنگاری و امضای دیجیتال استفاده می‌شود. این نرم‌افزار از استاندارد OpenPGP پیروی می‌کند و برای تضمین امنیت ارتباطات و حفاظت از داده‌های شخصی طراحی شده است.

به طور خاص در این برنامه از کتابخانه \lr{GPGME (GnuPG Made Easy)} برای ارتباط با \lr{GnuPG} استفاده شده است.
\lr{GPGME (GnuPG Made Easy)}
یک کتابخانه برای زبان \lr{C/C++} است که برای اضافه کردن پشتیبانی از رمزنگاری به برنامه‌ها طراحی شده است. این کتابخانه برای ساده‌تر کردن دسترسی به موتورهای رمزنگاری عمومی مانند \lr{GnuPG} یا \lr{GpgSM} طراحی شده است. \lr{GPGME} از \lr{GnuPG} به عنوان پشتیبان خود استفاده می‌کند و از پروتکل \lr{OpenPGP} و 
\lr{Cryptographic Message Syntax (CMS)}
 پشتیبانی می‌کند.
 
\subsection*{بخش دوم: نحوه استفاده از نرم‌افزار}

کاربر اول با صفحه زیر روبرو می‌شود. وی می‌تواند با زدن دکمه بالا به برنامه اصلی رفته یا در همین صفحه جفت کلید جدیدی را با وارد کردن ایمیل و زدن دکمه \lr{Generate New Keys} برای خود تولید کند.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{Pictures/gpg1.png} 
    \caption{صفحه اول برنامه}
    \label{figGPG1}
\end{figure}


پس از عبور از صفحه اول، کاربر وارد صفحه اصلی برنامه می‌شود که به صورت زیر می‌باشد.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Pictures/gpg2.png} 
    \caption{صفحه اصلی برنامه}
    \label{figGPG2}
\end{figure}

در برنامه اصلی اجزای صفحه به صورت زیر می‌باشد:
\begin{itemize}
    \item 
    لیست کلیدهای عمومی (\lr{Public Key}):
    در این قسمت کاربر می‌تواند لیست ایمیل افرادی را ببیند که به کلید عمومی آنها دسترسی داشته و می‌تواند برای آنها پیامی را رمزنگاری کند.
    
    \item
    لیست کلید‌های خصوصی (\lr{Private Key}):
    در این قسمت کاربر می‌تواند لیست ایمیل افرادی را ببیند که به کلید خصوصی آنها دسترسی داشته و از طریق آن می‌تواند پیامهای خود را امضا کند (در این برنامه امضا کردن پیام به صورت اجباری انجام می‌شود).
    \item 
    دکمه \lr{Import Key}:
    کاربر با فشردن این دکمه به صفحه انتخاب فایل هدایت می‌شود که وی در آن می‌تواند فایل مربوطه به کلیدهای موردنظر خود را انتخاب کرده و آنها را وارد برنامه بکند تا بتواند از آنها استفاده کند.
    
    \item 
    فیلد وارد کردن متن:
    در این بخش کاربر می‌تواند پیام مورد نظر خود را تایپ کرده و پس از انتخاب کلیدهای عمومی و خصوصی با فشردن دکمه \lr{Encrypt Text} پیام خود را برای فرد موردنظر رمز کند.
    
    \item 
    دکمه \lr{Encrypt Text}:
    با زدن این دکمه پیام بخش قبل برداشته شده و سپس در فایلی به صورت رمز شده ذخیره می‌شود.
    
    \item 
    دکمه \lr{Encrypt File}:
    کاربر با فشردن این دکمه به صفحه انتخاب فایل هدایت می‌شود و پس از انتخاب، فایل انتخاب شده وی رمزنگاری شده و ذخیره می‌شود.
    
    \item
    دکمه \lr{Decrypt}:
    کاربر با زدن این دکمه باز به صفحه انتخاب فایل هدایت می‌شود. در این صفحه کاربر می‌تواند فایل رمز شده‌ای را که برای وی ارسال شده است انتخاب کند. این فایل سپس رمزگشایی شده و در پوشه محلی ذخیره می‌شود.

    \item
    بخش گزارش:
    در این بخش برنامه گزارش‌های مختلف از جمله نام و محل ذخیره‌سازی فایلها و ارورهای پیش آمده را به کاربر نشان می‌دهد.
\end{itemize}

\subsection*{بخش سوم: نحوه پیاده‌سازی}

همانگونه که پیشتر ذکر شد این برنامه توسط \lr{API} های تامین شده توسط کتابخانه \lr{GPGME} امنیت خود را تامین می‌کند. در اینجا به عنوان مثال توابع رمزنگاری پیام و رمزگشایی فایل را بررسی می‌کنیم.

\textbf{تابع رمزنگاری پیام}:
(در اینجا از خطهای مربوط به مدیریت ارورها صرف نظر شده است)
\begin{LTR}
    \begin{minted}[breaklines,fontsize=\small,linenos=true]{cpp}
void MainWindow::on_encryptTextButton_clicked()
{
    gpgme_ctx_t ctx = nullptr;
    gpgme_key_t pubkey = nullptr, privkey = nullptr;
    gpgme_error_t err;
    gpgme_data_t plain = nullptr, encrypted = nullptr;
    
    QString plainText = ui->textLE->text();
    ui->textLE->clear();
    if (plainText.isEmpty()) {
        return;
    }
    
    if (!ui->privateKeyList->currentItem() || !ui->publicKeyList->currentItem())
    {
        addLogEntry("Please select both public and private keys");
        return;
    }
    QString privateEmail = ui->privateKeyList->currentItem()->text();
    QString publicEmail = ui->publicKeyList->currentItem()->text();
    
    err = gpgme_new(&ctx);
    ...
    err = gpgme_set_protocol(ctx, GPGME_PROTOCOL_OpenPGP);
    ...
    err = gpgme_get_key(ctx, publicEmail.toUtf8().constData(), &pubkey, 0);
    ...
    err = gpgme_get_key(ctx, privateEmail.toUtf8().constData(), &privkey, 1);
    ...
    err = gpgme_data_new_from_mem(&plain, plainText.toUtf8().constData(), plainText.size(), 1);
    ...
    err = gpgme_data_new(&encrypted);
    ...
    err = gpgme_signers_add(ctx, privkey);
    ...
    gpgme_key_t keys[] = {pubkey, nullptr};
    err = gpgme_op_encrypt_sign(ctx, keys, GPGME_ENCRYPT_ALWAYS_TRUST, plain, encrypted);
    ...
    QString timestamp = QDateTime::currentDateTime().toString("yyyyMMddhhmmss");
    QString filename = QString("%1.gpg").arg(timestamp);
    QFile file(filename);
    ...
    QByteArray encryptedData;
    char buffer[512];
    int n;

    if (gpgme_data_seek(encrypted, 0, SEEK_SET) == -1)
    {
        ...
    }
    
    while ((n = gpgme_data_read(encrypted, buffer, sizeof(buffer))) > 0) {
        encryptedData.append(buffer, n);
    }
    
    file.write(encryptedData);
    file.close();
    
    addLogEntry("The file has been successfully encrypted and saved as " + filename);
    
    gpgme_data_release(plain);
    gpgme_data_release(encrypted);
    gpgme_key_unref(pubkey);
    gpgme_key_unref(privkey);
    gpgme_release(ctx);
}
    \end{minted}
\end{LTR}

در این کد اول وجود پیام و انتخاب شدن کلیدهای عمومی و خصوصی بررسی می‌شود. سپس با تابع \lr{gpgme\_new} یک \lr{context} جدید برای عملیات تشکیل می‌شود. سپس با تابع \lr{gpgme\_set\_protocol} پروتکل مورد استفاده برابر با \lr{OpenPGP} قرار می‌گیرد. سپس با استفاده از تابع \lr{gpgme\_get\_key} کلیدهای متناظر با ایمیل‌ها دریافت می‌شود. سپس با تابع \lr{gpgme\_signers\_add} کلید خصوصی انتخاب شده به عنوان یک امضا کننده اضافه می‌شود، و در نهایت با استفاده از تابع \lr{gpgme\_op\_encrypt\_sign} پیام مورد نظر رمز می‌شود. بعد از انجام عملیات رمزگذاری محتوای رمزگذاری شده در فایلی به نام \lr{timestamp} فعلی ذخیره می شود و نام این فایل به کاربر اطلاع داده می‌شود.

\textbf{تابع رمزگشایی پیام}:
(در اینجا از خطهای مربوط به مدیریت ارورها صرف نظر شده است)
\begin{LTR}
    \begin{minted}[breaklines,fontsize=\small,linenos=true]{cpp}
void MainWindow::on_decryptButton_clicked()
{
    gpgme_ctx_t ctx;
    gpgme_error_t err;
    gpgme_data_t encrypted, plain;
    
    QString fileName = QFileDialog::getOpenFileName(nullptr, "Select Encrypted File");
    if (fileName.isEmpty()) {
        return;
    }
    
    QFile file(fileName);
    if (!file.open(QIODevice::ReadOnly)) {
    ...
    }
    
    QByteArray encryptedData = file.readAll();
    file.close();
    
    err = gpgme_new(&ctx);
    ...
    err = gpgme_set_protocol(ctx, GPGME_PROTOCOL_OpenPGP);
    ...
    err = gpgme_data_new_from_mem(&encrypted, encryptedData.constData(), encryptedData.size(), 1);
    ...
    err = gpgme_data_new(&plain);
    ...
    gpgme_decrypt_result_t decrypt_result;
    gpgme_verify_result_t verify_result;
    err = gpgme_op_decrypt_verify(ctx, encrypted, plain);
    ...
    decrypt_result = gpgme_op_decrypt_result(ctx);
    verify_result = gpgme_op_verify_result(ctx);
    
    if (decrypt_result->recipients->status != GPG_ERR_NO_ERROR) {
        ...
    }
    
    QString decryptedFileName = fileName + ".decrypted";
    QFile decryptedFile(decryptedFileName);
    if (!decryptedFile.open(QIODevice::WriteOnly)) {
        ...
    }
    
    QByteArray decryptedData;
    char buffer[512];
    int n;
    
    if (gpgme_data_seek(plain, 0, SEEK_SET) == -1)
    {
        ...
    }
    
    while ((n = gpgme_data_read(plain, buffer, sizeof(buffer))) > 0) {
        decryptedData.append(buffer, n);
    }
    
    decryptedFile.write(decryptedData);
    decryptedFile.close();
    
    addLogEntry("The file has been successfully decrypted and saved as " + decryptedFileName);
    
    gpgme_data_release(encrypted);
    gpgme_data_release(plain);
    gpgme_release(ctx);
}
    \end{minted}
\end{LTR}

در این کد اول دیالوگ انتخاب فایل نمایش داده می‌شود تا کاربر فایل خود را انتخاب کند. سپس با تابع \lr{gpgme\_new} یک \lr{context} جدید برای عملیات تشکیل می‌شود. سپس با تابع \lr{gpgme\_set\_protocol} پروتکل مورد استفاده برابر با \lr{OpenPGP} قرار می‌گیرد. سپس با استفاده از تابع \lr{gpgme\_op\_decrypt\_verify} پیام مورد نظر رمزگشایی شده و امضای آن تایید می‌شود. سپس با استفاده از توابع \lr{gpgme\_op\_decrypt\_result} و \lr{gpgme\_op\_verify\_result} وضعیت نهایی این عملیات‌ها خوانده می‌شود. در نهایت نیز محتوای فایل رمزگشایی شده در فایلی با پسوند \lr{.decrypted} ذخیره می‌شود و نام فایل به کاربر اطلاع داده می‌شود.

\section{سوال دوم}

\subsection*{بخش اول: محیط و ابزارهای مورد استفاده}

\subsubsection*{محیط توسعه}
برای پیاده‌سازی و مقایسه الگوریتم‌های \lr{AES} و \lr{RSA} از محیط توسعه \lr{Qt} با زبان ++C استفاده شده است. \lr{Qt} به دلیل داشتن ابزارهای قدرتمند برای طراحی رابط کاربری گرافیکی و همچنین امکانات گسترده برای ترسیم نمودارها، انتخاب مناسبی برای این پروژه بوده است. نسخه مورد استفاده شامل ماژول‌های \lr{core}، \lr{gui}، \lr{widgets} و \lr{charts} می‌باشد که برای طراحی رابط کاربری و نمایش نتایج به کار گرفته شده‌اند.

\subsubsection*{کتابخانه‌های مورد استفاده}
در این پروژه، از کتابخانه \lr{OpenSSL} برای پیاده‌سازی الگوریتم‌های \lr{AES} و \lr{RSA} استفاده شده است. \lr{OpenSSL} یک کتابخانه معتبر و قدرتمند در زمینه رمزنگاری است که امکانات متنوعی را برای پیاده‌سازی الگوریتم‌های رمزنگاری فراهم می‌کند. علاوه بر این، از کلاس‌های استاندارد \lr{Qt} مانند \lr{QElapsedTimer} برای اندازه‌گیری زمان و \lr{QChart} برای ترسیم نمودارها بهره گرفته شده است.

\subsubsection*{ساختار پروژه}
ساختار پروژه شامل فایل‌های زیر می‌باشد:
\begin{itemize}
    \item \textbf{\lr{mainwindow.cpp}} و \textbf{\lr{mainwindow.h}}: پیاده‌سازی رابط کاربری و تعاملات آن.
    \item \textbf{\lr{cryptotest.cpp}} و \textbf{\lr{cryptotest.h}}: پیاده‌سازی عملکردهای رمزنگاری و اندازه‌گیری زمان پاسخ‌دهی.
    \item \textbf{\lr{mainwindow.ui}}: تعریف رابط کاربری با استفاده از ابزار طراحی \lr{Qt}.
    \item \textbf{\lr{Q2.pro}}: فایل پروژه \lr{Qt} شامل تنظیمات و وابستگی‌های پروژه.
\end{itemize}

\subsection*{بخش دوم: پیاده‌سازی الگوریتم‌های AES و RSA}

\subsubsection*{پیاده‌سازی AES}
برای پیاده‌سازی \lr{AES-128-CBC} از توابع ارائه شده توسط \lr{OpenSSL} استفاده شده است. در این پیاده‌سازی، یک کلید \lr{AES} به طول 128 بیت به صورت تصادفی تولید شده و برای هر پیام، یک \lr{IV} (\lr{Initialization Vector}) نیز به صورت تصادفی ایجاد می‌شود تا امنیت عملیات رمزنگاری افزایش یابد. فرآیند رمزنگاری شامل مراحل \lr{Initialization}، \lr{EncryptUpdate} و \lr{EncryptFinal} است که به ترتیب برای راه‌اندازی کانتکست، رمزنگاری داده‌ها و پایان عملیات رمزنگاری استفاده می‌شوند.

یکی از توابع مهم در این بخش تابع \lr{\texttt{testAES}} در فایل \lr{\texttt{cryptotest.cpp}} است که زمان پاسخ‌دهی \lr{AES} را برای هر پیام اندازه‌گیری می‌کند.
این تابع برای هر پیام یک کانتکست جدید \lr{AES} ایجاد می‌کند، پیام را رمزنگاری می‌کند و زمان مورد نیاز برای این عملیات را ثبت می‌نماید.

\subsubsection*{پیاده‌سازی RSA}
برای پیاده‌سازی \lr{RSA} با طول کلید 3072 بیت، از توابع موجود در \lr{OpenSSL} استفاده شده است. ابتدا یک جفت کلید عمومی و خصوصی \lr{RSA} تولید می‌شود. سپس برای هر پیام، از کلید عمومی \lr{RSA} و پدینگ \lr{\texttt{RSA\_PKCS1\_OAEP\_PADDING}} برای رمزنگاری استفاده می‌شود. به دلیل محدودیت‌های \lr{RSA} در طول پیام قابل رمزنگاری، طول هر پیام به گونه‌ای انتخاب شده است که با توجه به طول کلید و پدینگ، امکان رمزنگاری آن فراهم باشد.

یکی از توابع مهم در این بخش تابع \lr{\texttt{testRSA}} در فایل \lr{\texttt{cryptotest.cpp}} است که زمان پاسخ‌دهی \lr{RSA} را برای هر پیام اندازه‌گیری می‌کند.
این تابع برای هر پیام، آن را با استفاده از کلید عمومی \lr{RSA} رمزنگاری کرده و زمان مورد نیاز برای این عملیات ثبت می‌گردد.

\subsection*{بخش سوم: مقایسه}

\subsubsection*{انتخاب طول کلید}
برای مقایسه عادلانه \lr{AES} و \lr{RSA} از نظر امنیت، طول کلیدهای این دو الگوریتم به گونه‌ای انتخاب شده‌اند که معادل از نظر امنیتی باشند. بر اساس منابع معتبر، کلید 128 بیتی \lr{AES} معادل امنیتی کلید 3072 بیتی \lr{RSA} می‌باشد. این انتخاب تضمین می‌کند که هر دو الگوریتم از نظر مقاومت در برابر حملات برابر هستند و نتایج مقایسه به طور مستقیم قابل مقایسه خواهند بود.

\subsubsection*{تولید پیام‌های تصادفی}
برای انجام مقایسه، هزار پیام تصادفی به طول 128 بایت تولید شده‌اند. از توابع \lr{\texttt{RAND\_bytes}} در \lr{OpenSSL} برای تولید داده‌های تصادفی استفاده شده است تا تضمین شود که داده‌ها به صورت کاملاً تصادفی و بدون الگوی خاصی تولید شوند. این پیام‌ها به عنوان ورودی برای عملیات رمزنگاری توسط هر دو الگوریتم \lr{AES} و \lr{RSA} استفاده شده‌اند.

\subsubsection*{اندازه‌گیری زمان پاسخ‌دهی}
زمان پاسخ‌دهی هر دو الگوریتم برای رمزنگاری هر پیام به صورت جداگانه اندازه‌گیری شده است. برای این منظور، از کلاس \lr{\texttt{QElapsedTimer}} در \lr{Qt} استفاده شده است که امکان اندازه‌گیری دقیق زمان‌های بسیار کوتاه را فراهم می‌کند. زمان‌های اندازه‌گیری شده به میلی‌ثانیه تبدیل و در وکتورهای جداگانه برای \lr{AES} و \lr{RSA} ذخیره شده‌اند. این داده‌ها سپس برای تحلیل و ترسیم نمودار \lr{BoxPlot} استفاده خواهند شد.

\subsubsection*{ترسیم نمودار BoxPlot}
برای نمایش توزیع زمان‌های پاسخ‌دهی \lr{AES} و \lr{RSA}, از نمودار \lr{BoxPlot} استفاده شده است. این نمودار شامل مقادیر مینیمم، بیشینه، میانه، چارک اول و سوم است که اطلاعات جامعی درباره پراکندگی و توزیع داده‌ها ارائه می‌دهد. استفاده از \lr{BoxPlot} امکان مقایسه بصری دقیق‌تر بین دو الگوریتم را فراهم می‌کند و نقاط قوت و ضعف هر یک را به وضوح نشان می‌دهد.

\subsection*{بخش چهارم: نتایج و تحلیل}

\subsubsection*{نمودار BoxPlot زمان پاسخ‌دهی}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Pictures/boxplot.png} 
    \caption{نمودار \lr{BoxPlot} مقایسه زمان پاسخ‌دهی \lr{AES} و \lr{RSA}}
    \label{fig:boxplot}
\end{figure}

\subsubsection*{تحلیل نتایج}
از نمودار \lr{BoxPlot} مشاهده می‌شود که الگوریتم \lr{AES-128-CBC} نسبت به \lr{RSA-3072} به طور قابل توجهی زمان پاسخ‌دهی کمتری دارد. این تفاوت عمدتاً به دلیل طبیعت الگوریتم‌های رمزنگاری متقارن و نامتقارن است. \lr{AES} به عنوان یک الگوریتم متقارن، برای رمزنگاری و رمزگشایی داده‌ها سریع‌تر عمل می‌کند زیرا عملیات ریاضی ساده‌تری را نسبت به \lr{RSA} انجام می‌دهد. از سوی دیگر، \lr{RSA} به دلیل پیچیدگی‌های بیشتری که در عملیات رمزنگاری دارد و نیاز به محاسبات عددی بزرگ، زمان بیشتری را صرف می‌کند.

همچنین، پراکندگی داده‌های زمان پاسخ‌دهی \lr{RSA} بیشتر از \lr{AES} است که نشان‌دهنده نوسانات بیشتری در زمان رمزنگاری \lr{RSA} نسبت به \lr{AES} می‌باشد. این امر می‌تواند به دلیل عوامل مختلفی مانند بار پردازشی سیستم یا پیچیدگی‌های داخلی \lr{RSA} باشد. به طور کلی، نتایج نشان‌دهنده این است که برای کاربردهایی که نیاز به رمزنگاری سریع دارند، \lr{AES} گزینه بهتری نسبت به \lr{RSA} است.

\subsection*{بخش پنجم: نتیجه‌گیری}

در این گزارش، به مقایسه زمان پاسخ‌دهی الگوریتم‌های \lr{AES} و \lr{RSA} در بستر \lr{Qt} با استفاده از زبان ++C پرداخته شد. نتایج نشان داد که \lr{AES-128-CBC} نسبت به \lr{RSA-3072} در رمزنگاری پیام‌ها سریع‌تر عمل می‌کند. این تفاوت عمدتاً به دلیل نوع الگوریتم‌های متقارن و نامتقارن و پیچیدگی‌های داخلی آن‌ها می‌باشد. با توجه به امنیت معادل انتخاب شده برای طول کلیدهای \lr{AES} و \lr{RSA}, می‌توان نتیجه گرفت که برای کاربردهایی که نیاز به رمزنگاری سریع دارند، \lr{AES} گزینه مناسبی است. از سوی دیگر، \lr{RSA} برای مواردی که نیاز به تبادل کلید یا ایجاد امضاهای دیجیتال دارند، همچنان کاربردی و مهم باقی می‌ماند.

\subsection*{بخش ششم: توابع مهم پیاده‌سازی}

در این بخش، به توضیح توابع کلیدی پیاده‌سازی در دو فایل \lr{\texttt{cryptotest.cpp}} و \lr{\texttt{mainwindow.cpp}} پرداخته می‌شود.

\subsubsection*{توابع اصلی در cryptotest.cpp}

\textbf{تابع \lr{\texttt{testAES}}}:

این تابع زمان پاسخ‌دهی الگوریتم \lr{AES} را برای هر پیام در وکتور ورودی اندازه‌گیری می‌کند. برای هر پیام، یک کانتکست جدید \lr{AES} ایجاد شده، پیام رمزنگاری می‌شود و زمان مورد نیاز برای این عملیات ثبت می‌گردد.
\begin{LTR}
    \begin{minted}[breaklines,fontsize=\small,linenos=true]{cpp}
QVector<double> CryptoTest::testAES(const QVector<QByteArray> &messages)
{
    QVector<double> times;
    times.reserve(messages.size());

    for (const QByteArray &msg : messages) {
        EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
        if (!ctx) {
            qWarning() << "Failed to create cipher context";
            continue;
        }

        unsigned char iv[16];
        RAND_bytes(iv, sizeof(iv));

        QElapsedTimer timer;
        timer.start();

        if (EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), nullptr, aesKey, iv) != 1) {
            qWarning() << "AES init failed";
            EVP_CIPHER_CTX_free(ctx);
            continue;
        }

        QByteArray ciphertext(msg.size() + EVP_MAX_BLOCK_LENGTH, 0);
        int len = 0;
        int ciphertext_len = 0;

        if (EVP_EncryptUpdate(ctx,
        reinterpret_cast<unsigned char*>(ciphertext.data()),
        &len,
        reinterpret_cast<const unsigned char*>(msg.constData()),
        msg.size()) != 1) {
            qWarning() << "AES encrypt update failed";
            EVP_CIPHER_CTX_free(ctx);
            continue;
        }
        ciphertext_len = len;

        if (EVP_EncryptFinal_ex(ctx,
        reinterpret_cast<unsigned char*>(ciphertext.data()) + len,
        &len) != 1) {
            qWarning() << "AES encrypt final failed";
            EVP_CIPHER_CTX_free(ctx);
            continue;
        }
        ciphertext_len += len;
        ciphertext.resize(ciphertext_len);

        double elapsedMs = timer.nsecsElapsed() / 1e6;
        times.push_back(elapsedMs);

        EVP_CIPHER_CTX_free(ctx);
    }

    return times;
}
    \end{minted}
\end{LTR}

\textbf{تابع \lr{\texttt{testRSA}}}:

این تابع زمان پاسخ‌دهی الگوریتم \lr{RSA} را برای هر پیام در وکتور ورودی اندازه‌گیری می‌کند. برای هر پیام، آن را با استفاده از کلید عمومی \lr{RSA} رمزنگاری کرده و زمان مورد نیاز برای این عملیات ثبت می‌گردد.
\begin{LTR}
    \begin{minted}[breaklines,fontsize=\small,linenos=true]{cpp}
QVector<double> CryptoTest::testRSA(const QVector<QByteArray>& messages)
{
    QVector<double> times;
    times.reserve(messages.size());
    
    int rsa_size = RSA_size(rsaKeyPair);
    
    for (const QByteArray &msg : messages) {
        QByteArray encrypted(rsa_size, 0);
        
        QElapsedTimer timer;
        timer.start();
        
        int encrypted_length = RSA_public_encrypt(
        qMin(msg.size(), rsa_size - 42),
        reinterpret_cast<const unsigned char*>(msg.constData()),
        reinterpret_cast<unsigned char*>(encrypted.data()),
        rsaKeyPair,
        RSA_PKCS1_OAEP_PADDING
        );
        
        double elapsedMs = timer.nsecsElapsed() / 1e6;
        
        if (encrypted_length == -1) {
            qWarning() << "RSA encryption failed:"
            << ERR_error_string(ERR_get_error(), nullptr);
            continue;
        }
        
        times.push_back(elapsedMs);
    }
    
    return times; 
}
    \end{minted}
\end{LTR}

\subsubsection*{توابع اصلی در mainwindow.cpp}

\textbf{تابع \lr{\texttt{onStartTest}}}:

این تابع هنگامی که کاربر بر روی دکمه \lr{\texttt{Start Test}} کلیک می‌کند، اجرا می‌شود. وظیفه این تابع تولید پیام‌های تصادفی، اجرای آزمون‌های \lr{AES} و \lr{RSA}، و ترسیم نمودار \lr{BoxPlot} است.

\textbf{تابع \lr{\texttt{onExportCSV}}}:

این تابع هنگامی که کاربر بر روی دکمه \lr{\texttt{Export CSV}} کلیک می‌کند، اجرا می‌شود. وظیفه این تابع صادر کردن نتایج آزمون‌های \lr{AES} و \lr{RSA} به یک فایل \lr{CSV} است.

\textbf{تابع \lr{\texttt{createBoxPlot}}}:

این تابع داده‌های زمان پاسخ‌دهی \lr{AES} و \lr{RSA} را دریافت کرده و نمودار \lr{BoxPlot} مربوطه را ترسیم می‌کند. نمودار شامل مقادیر مینیمم، بیشینه، میانه، چارک اول و سوم برای هر دو الگوریتم است.

\subsection*{بخش هفتم: چالش‌ها و راهکارها}
در فرآیند پیاده‌سازی و مقایسه الگوریتم‌های \lr{AES} و \lr{RSA} با استفاده از \lr{Qt} و ++C، با چالش‌های متعددی مواجه شدیم که مهم‌ترین آن‌ها عبارت بودند از:

\begin{itemize}
    \item \textbf{انتخاب و تنظیمات صحیح کتابخانه \lr{OpenSSL}:} اطمینان از سازگاری نسخه‌های مختلف \lr{OpenSSL} با پروژه و تنظیمات مناسب برای استفاده از توابع رمزنگاری از چالش‌های اصلی بود. مطالعه مستندات \lr{OpenSSL} و انجام تست‌های متعدد به ما کمک کرد تا این مشکلات را برطرف کنیم.
    
    
    \item \textbf{اندازه‌گیری دقیق زمان پاسخ‌دهی:} استفاده از ابزارهای دقیق مانند \lr{\texttt{QElapsedTimer}} برای اندازه‌گیری زمان رمزنگاری بدون دخالت عوامل خارجی ضروری بود. اجرای تست‌ها در محیط‌های کنترل‌شده و کاهش بار پردازشی سیستم به دقت اندازه‌گیری کمک کرد.
    
    \item \textbf{طراحی رابط کاربری مناسب:} ایجاد یک رابط کاربری کاربرپسند که امکان شروع تست، نمایش وضعیت و ترسیم نمودارها را به راحتی فراهم کند، از دیگر چالش‌های پروژه بود. استفاده از ابزارهای طراحی \lr{Qt Designer} و انجام تست‌های کاربری به بهبود تجربه کاربر منجر شد.
\end{itemize}

برای مقابله با این چالش‌ها، راهکارهای زیر اتخاذ شد:

\begin{itemize}
    \item مطالعه مستندات \lr{OpenSSL} و \lr{Qt} برای درک بهتر از نحوه استفاده و تعامل آن‌ها با ++C.
    
    \item اجرای تست‌های متعدد برای اطمینان از دقت اندازه‌گیری زمان پاسخ‌دهی و کاهش تأثیر عوامل خارجی.
    
    \item طراحی رابط کاربری با استفاده از ابزارهای طراحی \lr{Qt Designer} و تست‌های کاربری برای بهبود تجربه کاربر.
\end{itemize}

\subsection*{بخش هشتم: پیشنهادات}
برای بهبود عملکرد و افزایش دقت مقایسه‌ها، پیشنهاد می‌شود:

\begin{itemize}
    \item \textbf{افزایش تعداد پیام‌های تست شده:} افزایش تعداد پیام‌های تست شده به بیش از هزار پیام برای دستیابی به نتایج دقیق‌تر و کاهش تاثیر نوسانات تصادفی.
    
    \item \textbf{بررسی عملکرد الگوریتم‌ها در شرایط مختلف بار پردازشی سیستم:} تست عملکرد \lr{AES} و \lr{RSA} در سیستم‌هایی با بار پردازشی متفاوت به منظور درک بهتر از تاثیر شرایط محیطی بر زمان پاسخ‌دهی.
    
    \item \textbf{بهینه‌سازی کد:} بهینه‌سازی کدهای پیاده‌سازی شده برای کاهش زمان پاسخ‌دهی و افزایش کارایی کلی سیستم.
    
\end{itemize}

\section{سوال سوم}

برای دسترسی به محتویات رمزنگاری شده در درون بسته‌ها نیاز داریم تا به مرورگر خود بفهمانیم که باید \lr{Pre-Master-Secret} ها را در مکانی ذخیره کند تا بتوانیم از آنها در برنامه \lr{Wireshark} استفاده کنیم. در مرورگر فایرفاکس می‌توانیم با استفاده از متغیر محیطی \lr{SLLKEYLOGFILE} فایلی را برای ذخیره \lr{Pre-Master-Secret} ها تعیین کنیم.
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{Pictures/tls1.png}
    \label{tls1}
\end{figure}

سپس در برنامه \lr{Wireshark} از منوی بالا به بخش \lr{Edit -> Preferences} رفته و در منوی بغل \lr{Protocols -> TLS} را انتخاب کرده و فایل مورد نظر خود را در بخش \lr{(Pre)-Master-Secret log filename} انتخاب می‌کنیم.
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{Pictures/tls2.png}
    \label{tls2}
\end{figure}

حالا می‌توانیم به محتویات داخل بسته‌ها دسترسی داشته باشیم. در مثال پایین به سایت www.amazon.com وصل شده‌ایم و همانطور که مشاهده می‌شود فریم‌های \lr{http2} تبادل شده (با اینکه رمزگذاری شده‌اند) قابل مشاهده هستند. همچنین می‌توان مشاهده کرد که ۴ پیام برای برقراری ارتباط \lr{TLS} رد و بدل شده است که در ادامه به محتویات آنها خواهیم پرداخت.
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{Pictures/tls3.jpg}
    \label{tls3}
\end{figure}

تصویر زیر محتویات پیام اول را نشان می‌دهد که شامل رکورد \lr{Client Hello} می‌باشد. این رکورد شامل فیلدهای زیر می‌باشد:
\begin{itemize}

\item \lr{Version}:
فیلد نسخه که نسخه ارتباطات را مشخص می‌کند. این فیلد در \lr{TLS 1.3} استفاده نمی‌شود و همواره دارای مقادیر \lr{0x301} به معنای \lr{TLS 1.0} یا \lr{0x303} به معنای \lr{TLS 1.2} می‌باشد.
\item \lr{Random}:
یک عدد رندوم ۳۲ بایتی که توسط کلاینت تولید شده است و در تولید کلیدهای نهایی برای رمزنگاری نقش دارد.

\item \lr{Session ID}:
یک شناسه یکتا که مختص این اتصال می‌باشد و برای سرگیری اتصال در اتصال‌های بعد استفاده می‌شود تا سرعت اتصال مجدد بهبود یافته و میزان اطلاعات تکراری کمتر شود.
\item \lr{Cipher Suites}:
الگوریتم‌های رمزنگاری را مشخص می‌کند که کلاینت از آنها پشتیبانی می‌کند و مایل است که در این اتصال از آن استفاده کند.
\item \lr{Compression Methods}:
الگوریتم‌های فشرده‌سازی را مشخص می‌کند که کلاینت مایل است از آنها استفاده شود (در این مثال این فیلد خالی می‌باشد که به معنای فشرده نبودن پیام‌ها می‌باشد).

\end{itemize}

سپس چندین \lr{extension} رد و بدل می‌شود که محتویات این اکستنشن‌ها برای عملکرد این پروتکل مهم است. اکستنشن‌های مهم در این پیام عبارتند از:
\begin{itemize}

\item \lr{server\_name}:
دامنه سروری که کلاینت می‌خواهد به آن متصل شود.

\item \lr{supported\_groups}:
منحنی بیضی و گروه‌های میدان محدودی را که کلاینت برای تبادل کلید از آنها پشتیبانی می کند نشان می‌دهد و مربوط به رمزنگاری بیضوی دیفی-هلمن می‌باشد.

\item \lr{session\_ticket}:
این فیلد مشخص می‌کند که آیا کلاینت دارای \lr{Session Ticket} ای می‌باشد یا خیر. از \lr{Session Ticket} برای کاهش طول فرآیند دست دادن در اتصال مجدد به یک سرور استفاده می‌شود.

\item \lr{application\_layer\_protocol\_negotiation}:
پروتکل‌های لایه کاربرد که کلاینت مایل است از آنها استفاده کند (در این مثال پروتکل‌های موجود h2 و http1.1 می‌باشند).

\item \lr{status\_request}:
روش بررسی ملغی شدن گواهی که در این مثال OCSP می‌باشد. از این اکستنشن معمولا در روش \lr{OCSP Stapling} برای درخواست انجام این بررسی در سمت سرور استفاده می‌شود.

\item \lr{key\_share}:
اطلاعات مربوط به توافق کلید کلاینت در روش‌های مبتنی بر دیفی-هلمن.

\item \lr{supported\_versions}:
نسخه‌های TLS پشتیبانی شده توسط کلاینت. در این اکستنشن نسخه‌های واقعی پروتکل تعیین می‌شود.

\item \lr{signature\_algorithms}:
الگوریتم‌های امضای دیجیتالی که کلاینت از انها پشتیبانی می‌کند.

\item \lr{record\_size\_limit}:
این اکستنشن سایز هر رکورد را برای این ارتباط محدود می‌کند.

\item \lr{compress\_certificate}:
این اکستنشن از سرور درخواست می‌کند که گواهی خود را فشرده کرده و الگوریتم‌های فشرده‌سازی پشتیبانی شده توسط کلاینت را تعیین می‌کند.

\item \lr{encrypted\_client\_hello}:
این اکستنشن شامل فیلدهای حساس \lr{Client Hello} می‌باشد که به صورت رمز شده برای سرور ارسال می‌شود.

\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{Pictures/tls4.jpg}
    \label{tls4}
\end{figure}

تصویر زیر محتویات پیام دوم را نشان می‌دهد که شامل چندین رکورد می‌باشد. اولین رکورد یعنی Server Hello شامل فیلدهای زیر و اکستنشن‌های می‌باشد:
\begin{itemize}
\item \lr{Random}:
یک عدد رندوم ۳۲ بایتی که توسط سرور تولید شده است و در تولید کلیدهای نهایی برای رمزنگاری نقش دارد.

\item \lr{Session ID}:
شناسه یکتایی که توسط کلاینت تولید شده و توسط سرور تائید شده است.

\item \lr{Cipher Suite}:
الگوریتم رمزنگاری که قرار است از آن در این اتصال از آن استفاده شود.

\item \lr{Compression Method}:
الگوریتم فشرده‌سازی که قرار است از آن استفاده شود (در این مثال از فشرده‌سازی استفاده نشده است).

\item \lr{supported\_versions}:
نسخه پروتکل TLS که از آن استفاده می‌شود. نسخه واقعی پروتکل در این فیلد مشخص شده است.

\item \lr{key\_share}:
اطلاعات مربوط به توافق کلید سرور در روش‌های مبتنی بر دیفی-هلمن.

\end{itemize}

رکورد بعدی \lr{Change Cipher Spec} می‌باشد که شامل فیلدی نبوده و صرفا به کلاینت اطلاع می‌دهد که از اینجا به بعد اطلاعات رد و بدل شده به صورت رمزی فرستاده می‌شوند. رکورد بعدی \lr{Encrypted Extensions} می‌باشد که اکستنشن‌های زیر را به صورت رمزی برای کلاینت می‌فرستد:
\begin{itemize}
\item \lr{server\_name}:
دامنه سروری که کلاینت به آن وصل شده است که در این مثال خالی می‌باشد (یعنی سرور وصل شده برابر با SNI اولیه می‌باشد).

\item \lr{supported\_groups}:
منحنی بیضی و گروه‌های میدان محدودی را که سرور برای تبادل کلید از آنها استفاده می‌کند نشان می‌دهد و مربوط به رمزنگاری بیضوی دیفی-هلمن می‌باشد.

\item \lr{application\_layer\_protocol\_negotiation}:
پروتکل لایه کاربردی می‌باشد که سرور قبول کرده است (در این مثال این مقدار h2 یا همان http2 می‌باشد).

\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{Pictures/tls5.jpg}
    \label{tls5}
\end{figure}

تصویر زیر محتویات پیام سوم را نشان می‌دهد که در آن سه رکورد TLS وجود دارد. رکورد اول صرفا شامل گواهی سرور برای تائید صحت کلید عمومی به اشتراک گذاشته شده در \lr{key\_share} پیام قبل می‌باشد. در رکورد بعدی به نام \lr{Certificate Verify} سرور در اختیار داشتن کلید خصوصی متناظر با کلید عمومی درج شده در گواهی را به کلاینت اثبات می‌کند. این رکورد شامل یک امضا (که الگوریتم هش آن در این رکورد نیز ذکر شده است) از تمام محتویات دست دادن TLS تا پایان ارسال گواهی می‌باشد که در صورتی که کلاینت بتواند این امضا را تایید کند در دست داشتن کلید خصوصی گواهی برای کلاینت اثبات می‌شود.

در آخر نیز رکورد Finished می‌باشد. این رکورد دارای یک هش (\lr{Verify Data}) از تمامی پیام‌های ردوبدل شده در طول دست دادن می‌باشد تا کلاینت بتواند صحت اطلاعات پیام‌های دریافتی را با استفاده از مقایسه این هش با هش محاسبه شده توسط خود تایید کند.
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{Pictures/tls6.jpg}
    \label{tls6}
\end{figure}

تصویر زیر محتویات پیام چهارم و آخر را نشان می‌دهد که در آن دو رکورد TLS وجود دارد. رکورد اول \lr{Change Cipher Spec} می‌باشد که به سرور اطلاع می‌دهد از این به بعد کلاینت پیام‌های خود را به صورت رمز شده ارسال می‌کند. رکورد دوم نیز رکورد \lr{Finished} می‌باشد که هدف آن در بخش قبلی توضیح داده شد.
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{Pictures/tls7.jpg}
    \label{tls7}
\end{figure}

پس از دست دادن سرور برای کلاینت دو \lr{Session Ticket} می‌فرستد که برای کوتاه کردن فرآیند دست دادن در اتصال‌های بعدی می‌باشد و از دامنه این سوال خارج می‌باشد. در نهایت بعد از طی این مراحل دو طرف می‌توانند برای یکدیگر اطلاعات خود را به صورت رمزی با اطمینان از صحت آنها ارسال کنند.

\end{document}
